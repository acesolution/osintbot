
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3-org-chart@3.1.0"></script>
<script src="https://cdn.jsdelivr.net/npm/d3-flextree@2.1.2/build/d3-flextree.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" />
<link href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.4/dist/umd/popper.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>

<!-- Vendors styles-->
<link rel="stylesheet" href="vendors/simplebar/css/simplebar.css">
<!-- Main styles for this application-->
<link href="css/style.css" rel="stylesheet">
<!-- We use those styles to show code examples, you should remove them in your application.-->
<link href="css/examples.css" rel="stylesheet">
<script src="js/config.js"></script>

<style type="text/css">
  .hide {
    display: none !important;
  }

  .drag-enabled:not(.dragging-active) .node.draggable {
    stroke: grey;
    stroke-width: 3px;
    stroke-dasharray: 2px;
  }

  .drag-enabled.dragging-active .droppable {
    stroke: green;
    stroke-width: 3px;
    stroke-dasharray: 5px;
  }

  .node.dragging {
    stroke-dasharray: 0 !important;
    stroke-width: 0 !important;
  }

  .node.dragging .content-container {
    background-color: #ffffff;
  }
  
  
  .chart-holder {
    width: 100%;
    height: 100%;
    overflow: hidden;
    padding-left: 0;
    padding-right: 0;
    background-color: white;
  }
  /* Customize the navbar height */
    .custom-navbar {
        height: 50px;
        line-height: 50px;
    }

    /* Center align the icons in the navbar */
    .navbar .mx-auto {
        display: flex;
        justify-content: center;
        width: 100%;
    }

    /* Style the profile icon */
    .navbar .ml-auto .nav-link {
        font-size: 1.5rem;
    }

    /* Adjust icon sizes */
    .navbar .nav-link i {
        font-size: 1.25rem;
    }

    /* Remove extra padding from the navbar brand */
    .navbar .navbar-brand {
        margin-right: auto;
        padding-left: 0;
    }
    .btn {
      margin: 3px;
      color: inherit;
      text-transform: uppercase;
      word-wrap: break-word;
      white-space: normal;
      cursor: pointer;
      border: 0;
      border-radius: 0.125rem;
      -webkit-box-shadow: 0 2px 5px 0 rgb(0 0 0 / 16%),
        0 2px 10px 0 rgb(0 0 0 / 12%);
      box-shadow: 0 2px 5px 0 rgb(0 0 0 / 16%), 0 2px 10px 0 rgb(0 0 0 / 12%);
      -webkit-transition: color 0.15s ease-in-out,
        background-color 0.15s ease-in-out, border-color 0.15s ease-in-out,
        -webkit-box-shadow 0.15s ease-in-out;
      transition: color 0.15s ease-in-out, background-color 0.15s ease-in-out,
        border-color 0.15s ease-in-out, -webkit-box-shadow 0.15s ease-in-out;
      transition: color 0.15s ease-in-out, background-color 0.15s ease-in-out,
        border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
      transition: color 0.15s ease-in-out, background-color 0.15s ease-in-out,
        border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out,
        -webkit-box-shadow 0.15s ease-in-out;
      padding: 0.84rem 2.14rem;
      font-size: 0.81rem;
      display: inline-block;
      font-weight: 400;
      color: #212529;
      text-align: center;
      vertical-align: middle;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      border: 1px solid transparent;
      padding: 0.375rem 0.75rem;
      font-size: 1rem;
      line-height: 1.5;
      border-radius: 0.25rem;
    }

    .btn-action-button {
      text-transform: lowercase;
      font-size: 12px !important;
      border-radius: 7px !important;
      color: black !important;
      padding: 4px 5px !important;
      background-color: white !important;
      z-index: 1500;
    }

    .action-buttons {
      display:none;
      position: absolute;
      top: 70px;
      right: 30px;
      transition: max-height 0.3s ease-out;
    }
    .action-buttons.open {
      display: block;
      transition: max-height 0.5s ease-in;
    }

    .svg-chart-container:before {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      background: radial-gradient(circle at center, #04192b 0, #000b0e 100%);
    }
    .svg-chart-container{
      height:100%;
    }
    .zoom-buttons {
      position: absolute;
      padding:10px;
      z-index: 10;
      display: flex;
      flex-direction: column;
    }
    
    .zoom-buttons button {
        width: 30px;
        height: 30px;
        background-color: #ffffff;
        border: 1px solid #ccc;
        border-radius: 5px;
        margin-bottom: 2px;
        font-size: 18px;
        line-height: 1;
        text-align: center;
        cursor: pointer;
        padding: 0;
    }
    
    .zoom-buttons button:hover {
        background-color: #e0e0e0;
    }

  

</style>

<script>
  var chart = null;
  let dragNode;
  let dropNode;
  let dragEnabled = false;
  let dragStartX;
  let dragStartY;
  let isDragStarting = false;

  let undoActions = [];
  let redoActions = [];

  // This is the data used - https://github.com/bumbeishvili/sample-data/blob/main/data-oracle.csv
  const data = [
    {
      id: 100,
      parentId: null,
      name: 'Steven',
      position: 'Chief Operating Officer',
      image: 'https://bumbeishvili.github.io/avatars/avatars/portrait12.png',
      
    },
    {
      id: 101,
      parentId: 100,
      name: 'Neena',
      position: 'Administration Vice President',
      image: 'https://bumbeishvili.github.io/avatars/avatars/portrait85.png',
      
    },
    {
      id: 102,
      parentId: 100,
      name: 'Lex',
      position: 'Administration Vice President',
      image: 'https://bumbeishvili.github.io/avatars/avatars/portrait16.png',
      
    },
    {
      id: 103,
      parentId: 101,
      name: 'Lex',
      position: 'Administration Vice President',
      image: 'https://bumbeishvili.github.io/avatars/avatars/portrait16.png',
      
    },
  ]


  
  d3.csv(
    'https://raw.githubusercontent.com/bumbeishvili/sample-data/main/data-oracle.csv'
  ).then((data) => {
    const limitedData = data.slice(0, 20);
    chart = new d3.OrgChart()
      .nodeHeight((d) => 85 + 25)
      .nodeWidth((d) => 220 + 2)
      .childrenMargin((d) => 50)
      .compactMarginBetween((d) => 20)
      .siblingsMargin(function (d) {
        return 30;
      })
      .compactMarginPair(function (d) {
        return 30;
      })
      .neighbourMargin(function(a, b) { 
        return 30;
      })
      .nodeContent(function (d, i, arr, state) {
        return generateContent(d);
      })
      .nodeEnter(function (node) {
        d3.select(this).call(
          d3
            .drag()
            .filter(function (x, node) {
              return dragEnabled && this.classList.contains('draggable');
            })
            .on('start', function (d, node) {
              onDragStart(this, d, node);
            })
            .on('drag', function (dragEvent, node) {
              onDrag(this, dragEvent);
            })
            .on('end', function (d) {
              onDragEnd(this, d);
            })
        );
      })
      .nodeUpdate(function (d) {
        if (d.id === '120' || d.id === '124') {
          d3.select(this).classed('droppable', false);
        } else {
          d3.select(this).classed('droppable', true);
        }

        if (d.id === '10') {
          d3.select(this).classed('draggable', false);
        } else {
          d3.select(this).classed('draggable', true);
        }
      })
      .container('.chart-container')
      .data(limitedData)
      .render();
      /*.linkUpdate(function (d, i, arr) {
        //console.log('d', d, i, arr);
        let arrowStart =  "url(#arrow-start)";
        if (d.compactEven === null){
          arrowStart = "url(#arrow-down)";
        }
        d3.select(this)
          .attr("stroke","#C0C0C0")
          .attr('stroke-linecap', 'round')
          .attr("stroke-width", '5')
          .attr('pointer-events', 'none')
          .attr("marker-start", arrowStart)
          .attr("marker-end", d => "url(#arrow-end)")
      })*/
      
    // Add event listeners to list items after the DOM has loaded
    addDragEventListenersToFilterItems();
    addDropEventListenersToChart(); 
  });
  
   
  function addDragEventListenersToFilterItems() {
    const filterLists = document.querySelectorAll('.nav-group-items a');
    filterLists.forEach((item) => {
      item.setAttribute('draggable', true); // Make the list items draggable
  
      item.addEventListener('dragstart', function (e) {
        e.dataTransfer.setData('text/plain', e.target.textContent.trim());
        e.dataTransfer.effectAllowed = 'copy';
      });
    });
  }
  
  function addDropEventListenersToChart() {
    const chartContainer = document.querySelector('.chart-container');
    chartContainer.addEventListener('dragover', function (e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'copy'; // Indicate the type of operation
    });
    chartContainer.addEventListener('drop', function (e) {
      e.preventDefault();
      const nodeName = e.dataTransfer.getData('text/plain');
      // Capture the mouse position (drop position)
      const dropX = e.clientX - chartContainer.getBoundingClientRect().left;
      const dropY = e.clientY - chartContainer.getBoundingClientRect().top;
      if (nodeName) {
        addNodeToChart(nodeName, dropX, dropY);
      }
    });
  }
  
  function addNodeToChart(nodeName, dropX, dropY) {
     // Define a map to associate node names with icon classes
    const iconMap = {
        "Email": "https://cdn-icons-png.freepik.com/512/552/552486.png",
        "Phone Number": "https://cdn-icons-png.freepik.com/512/15094/15094539.png",
        "Text": "https://cdn-icons-png.freepik.com/512/16799/16799604.png",
        "Mathematics": "https://cdn-icons-png.freepik.com/512/5199/5199365.png",
        "Easy": "https://cdn-icons-png.freepik.com/512/12366/12366732.png",
        "Medium": "fa fa-adjust",
        "Hard": "https://cdn-icons-png.freepik.com/512/9750/9750980.png"
    };
    let lastId = 0;
    const data = chart.getChartState().data;
    //console.log('chart.getChartState()', chart.getChartState());
    // Find the highest existing numeric ID
    data.forEach(node => {
        const nodeId = parseInt(node.id, 10); // Parse the ID as an integer
        if (!isNaN(nodeId) && nodeId > lastId) {
            lastId = nodeId;
        }
    });

    // Generate a new ID by incrementing the last ID
    const newId = (lastId + 1);
    // Get the appropriate icon class based on the node name
    const iconClass = iconMap[nodeName] || "fa fa-question"; // Default to a question mark icon if no match is found
    
    chart.addNode({
      id: newId,
      name: nodeName,
      position: "Newly Added",  // Customize this
      parentId: '100',  // Replace with actual parent ID or logic
      image: iconClass,
      x: dropX,  // Store the drop X position
      y: dropY   // Store the drop Y position
    });
  
    // Update chart data
    //data.push(newNode);
    //chart.data(data).render();
    let width =110; 
    let height=222; 
    let x = dropX;
    let x0 = dropX;
    let y = dropY;
    let y0 = dropY;
    //console.log('dropX', dropX, 'dropY', dropY);
    const attrs = chart.getChartState();
    zoomLevel = attrs.lastTransform.k;
    // Get the position offsets caused by dragging the chart
    const rootOffsetX = attrs.lastTransform.x;
    const rootOffsetY = attrs.lastTransform.y;

    ////console.log(attrs.calc.centerY, attrs.calc.centerX, zoomLevel, rootOffsetX, rootOffsetY);
    
    // Adjust dropX and dropY to account for centerX, centerY, root offsets, and zoom
    if(rootOffsetX > 0){
      dropX = (dropX - attrs.calc.centerX + rootOffsetX) / zoomLevel;
    }else{
      dropX = (dropX - attrs.calc.centerX - rootOffsetX) / zoomLevel;
    }
    //console.log('BeforedropY', dropY, zoomLevel);
    if(zoomLevel <= 1 && zoomLevel >= 0.8){
      dropY = dropY * zoomLevel;
      console.log('inIf', dropY);
    }
    else{
      dropY = dropY
      console.log('inElse', dropY);
    }
    console.log('AfterdropY', dropY);
    attrs.allNodes = attrs.root.descendants();
    attrs.allNodes.forEach(d => {
      
      if(d.id === String(newId)){
        //console.log('matched');
        updatePathBasedOnDrop(d, 'nodeEvent', dropX, dropY);
      }
    })

    
    // Attach click event to the newly added node
    d3.selectAll('#node-container')
      .on('click', function(d) {
        selectNode(`"${d.data.id}"`); // Pass the ID as a string
      });
  }
  
  function onDragStart(element, dragEvent, node) {
    dragNode = node;
    const width = dragEvent.subject.width;
    const half = width / 2;
    const x = dragEvent.x - half;
    dragStartX = x;
    dragStartY = parseFloat(dragEvent.y);
    isDragStarting = true;

    d3.select(element).classed('dragging', true);
  }

  function onDrag(element, dragEvent) {
    if (!dragNode) {
      return;
    }

    const state = chart.getChartState();
    const g = d3.select(element);

    // This condition is designed to run at the start of a drag only
    if (isDragStarting) {
      isDragStarting = false;
      document
        .querySelector('.chart-container')
        .classList.add('dragging-active');

      // This sets the Z-Index above all other nodes, by moving the dragged node to be the last-child.
      g.raise();

      const descendants = dragEvent.subject.descendants();
      const linksToRemove = [...(descendants || []), dragEvent.subject];
      const nodesToRemove = descendants.filter(
        (x) => x.data.id !== dragEvent.subject.id
      );

      // Remove all links associated with the dragging node
      state['linksWrapper']
        .selectAll('path.link')
        .data(linksToRemove, (d) => state.nodeId(d))
        .remove();

      // Remove all descendant nodes associated with the dragging node
      if (nodesToRemove) {
        state['nodesWrapper']
          .selectAll('g.node')
          .data(nodesToRemove, (d) => state.nodeId(d))
          .remove();
      }
    }

    dropNode = null;
    const cP = {
      width: dragEvent.subject.width,
      height: dragEvent.subject.height,
      left: dragEvent.x,
      right: dragEvent.x + dragEvent.subject.width,
      top: dragEvent.y,
      bottom: dragEvent.y + dragEvent.subject.height,
      midX: dragEvent.x + dragEvent.subject.width / 2,
      midY: dragEvent.y + dragEvent.subject.height / 2,
    };

    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const allNodes = d3.selectAll('g.node:not(.dragging)');
    allNodes.select('rect').attr('fill', 'none');

    allNodes
      .filter(function (d2, i) {
        const cPInner = {
          left: d2.x,
          right: d2.x + d2.width,
          top: d2.y,
          bottom: d2.y + d2.height,
        };

        if (
          cP.midX > cPInner.left &&
          cP.midX < cPInner.right &&
          cP.midY > cPInner.top &&
          cP.midY < cPInner.bottom &&
          this.classList.contains('droppable')
        ) {
          dropNode = d2;
          return d2;
        }
      })
      .select('rect')
      .attr('fill', '#e4e1e1');

    dragStartX += parseFloat(dragEvent.dx);
    dragStartY += parseFloat(dragEvent.dy);
    g.attr('transform', 'translate(' + dragStartX + ',' + dragStartY + ')');
  }

  function onDragEnd(element, dragEvent) {
    //console.log('dragNode', dragNode);
    //console.log('dropNode', dropNode);
    

    document
      .querySelector('.chart-container')
      .classList.remove('dragging-active');

    if (!dragNode) {
      //console.log('dragnode');
      return;
    }

    d3.select(element).classed('dragging', false);

    if (!dropNode) {
      //console.log('dropnode');
      //chart.render();
      const data = chart.getChartState().data;
      const node = data.find((x) => String(x.id) === String(dragEvent.subject.id));
      if (node) {
        updatePathBasedOnDrop(dragEvent, "dragevent", 10,20); // Pass the node itself
      }
      return;
    }

    if (dragEvent.subject.parent.id === dropNode.id) {
      chart.render();
      return;
    }
    d3.select(element).remove();

    const data = chart.getChartState().data;
    const node = data?.find((x) => x.id === dragEvent.subject.id);
    const oldParentId = node.parentId;
    node.parentId = dropNode.id;

    redoActions = [];
    undoActions.push({
      id: dragEvent.subject.id,
      parentId: oldParentId,
    });

    dropNode = null;
    dragNode = null;
    //chart.render();
    updateDragActions();
  }

  
  let tempNodeSave = {};
  let tempNodeChildSave = {};
  let chlidInfoNode = {};
  let childCount = {};
  let tempChildCount = {};
  let checkExpandCollapse = {};

  function updatePathBasedOnDrop(node_main, parameter, dropX, dropY) {
    const layout = chart.layoutBindings(); // Current layout bindings
    const data = chart.getChartState().data;
    //console.log('main node', node_main);

    function calculateCompactFlexPositions (root) {
      const attrs = chart.getChartState();
      root.eachBefore(node => {
        if (node.children) {
          const compactChildren = node.children.filter(d => d.flexCompactDim);
          const fch = compactChildren[0];
          
          if (!fch){ 
            //console.log('fch', fch);
            return
          }else{
            //console.log('else fch', fch);
          }
          //console.log('returned');
          // Adjust x positions of compact children
          compactChildren.forEach((child, i, arr) => {

            //console.log('compactChild', child, child.x, child.y, child.id);
            if (i == 0) {
              fch.x -= fch.flexCompactDim[0] / 2;
              //console.log('fch.x', fch.x, child.id);
            }
            if (i & i % 2 - 1) 
            {
              child.x = fch.x + fch.flexCompactDim[0] * 0.25 - attrs.compactMarginPair(child) / 4;
              //console.log('child.x if', child.x, child.id);
            }
            else if (i) {
              child.x = fch.x + fch.flexCompactDim[0] * 0.75 + attrs.compactMarginPair(child) / 4;
              //console.log('child.x else', child.x, child.id);
            }

          });

          // Calculate center position and apply offset
          const centerX = fch.x + fch.flexCompactDim[0] * 0.5;
          fch.x = fch.x + fch.flexCompactDim[0] * 0.25 - attrs.compactMarginPair(fch) / 4;
          const offsetX = node.x - centerX;
          if (Math.abs(offsetX) < 10) {
            compactChildren.forEach(d => d.x += offsetX);
          }

          // Group by rows and adjust y positions
          const rowsMapNew = chart.groupBy(
            compactChildren, 
            d => d.row, 
            reducedGroup => d3.max(reducedGroup, d => 
              attrs.layoutBindings[attrs.layout].compactDimension.sizeRow(d)
            )
          );
          const cumSum = d3.cumsum(rowsMapNew.map(d => d[1] + attrs.compactMarginBetween(d)));
          compactChildren.forEach((node, i) => {
            if (node.row) {
              node.y = fch.y + cumSum[node.row - 1];
            } else {
              node.y = fch.y;
            }
          });

          // Add your custom coordinate adjustments here
          // Example: Further adjust x/y based on additional conditions
          compactChildren.forEach((child) => {
            //console.log('compact child 2', child, child.id, child.x, child.y );
            // Adjust toAssignX if firstCompact is null
            /*if (child.firstCompact === null) {
              toAssignX += (toAssignX > 0) ? 30 : -30;
              console.log('toAssignX', toAssignX);
            }*/
            //console.log('child', child.id);
            if(child.id === node_secondry.id){
              //console.log('before',child.x);
              child.x = toAssignX;
              child.y = toAssignY;
              //console.log('after',child.x);
              tempNodeChildSave[child.id] = {
                parentId: child.parent.id,
                id:child.id,
                x: toAssignX,
                y: toAssignY,
                width: '222',
                nodeSelf: child,
              };
            }
            else{
              for (const [id, savedData] of Object.entries(tempNodeChildSave)) {
                if (savedData.id === child.id) {
                  //console.log('linkCompactXStart loop',child.x, child.y, savedData.x, savedData.y );
                  child.x = savedData.x;
                  child.y = savedData.y;
                  
                }
              }
            }
          });
        }
      });
    };  

    function restyleForeignObjectElements() {
      const attrs = this.getChartState();

      attrs.svg
          .selectAll(".node-foreign-object")
          .attr("width", ({ width }) => width)
          .attr("height", ({ height }) => height)
          .attr("x", ({ width }) => 0)
          .attr("y", ({ height }) => 0);
      attrs.svg
          .selectAll(".node-foreign-object-div")
          .style("width", ({ width }) => `${width}px`)
          .style("height", ({ height }) => `${height}px`)
          .html(function (d, i, arr) {
              if (d.data._pagingButton) {
                  return `<div class="paging-button-wrapper"><div style="pointer-events:none">${attrs.pagingButton(d, i, arr, attrs)}</div></div>`;
              }
              return attrs.nodeContent.bind(this)(d, i, arr, attrs)
          })
    }

    

    // Recursive function to traverse through children and update their x and y values
    /*function updateChildCoordinates(node) {
      console.log('node', node.x, node.y, node.depth, node);
      const attrs = chart.getChartState();

      //console.log('coordinate node before', node.id, node);
      // Check if the current node's ID exists in tempNodeChildSave
      if (tempNodeChildSave[node.data.id]) {
        // Get predefined values for that node ID
        const predefinedValues = tempNodeChildSave[node.data.id];
        // Update the x and y values based on predefined values
        //console.log(`Before Update - Node ID: ${node.data.id}, X: ${node.x}, Y: ${node.y}`);
        node.x = predefinedValues.x; // Update x
        node.y = predefinedValues.y; // Update y
        node.x0 = predefinedValues.x; // Update x0
        node.y0 = predefinedValues.y; // Update y0
        //console.log(`After Update - Node ID: ${node.data.id}, New X: ${node.x}, New Y: ${node.y}`);

      }

      if(node.data.id === node_secondry.id){
        console.log('running this', node_secondry.x, node_main.x);
        let nodeX = node_main.x;
        let nodeY = node_main.y;
        /*if (node_secondry.firstCompact === null) {
          nodeX += (nodeX > 0) ? 120 : -120;
        }
        node.x = nodeX; // Update x
        node.y = nodeY; // Update y
        node.x0 = nodeX; // Update x0
        node.y0 = nodeY; // Update y0

        tempNodeChildSave[node_secondry.id] = {
          parentId: node_secondry.parent.id,
          id:node_secondry.id,
          x: nodeX,
          y: nodeY,
          width: '222',
          nodeSelf: node,
        };

      }
      
      if(node.parent.id === node_secondry.id){
        //console.log('child of', node, node_main);
        let nodeX = node.parent.x;
        let nodeY = node.parent.y + 200;
        console.log('bofore x', nodeX);
        if(node.compactEven === true){
          nodeX -= 150;
        }else if((node.compactEven === false)){
          nodeX += 150;
        }
        console.log('after x', nodeX);
        
        node.x = nodeX; // Update x
        node.y = nodeY; // Update y
        node.x0 = nodeX; // Update x0
        node.y0 = nodeY; // Update y0

        tempNodeChildSave[node.id] = {
          parentId: node.parent.id,
          id:node.id,
          x: nodeX,
          y: nodeY,
          width: '222',
          nodeSelf: node,
        };

      }
      //console.log('coordinate node after', node.id, node.x,node.y, node);


      const nodeWidth = 222;  // Assuming a fixed width for all nodes
      const nodeHeight = 110; // Assuming a fixed height for all nodes
      const padding = 10;     // Padding between nodes to avoid overlap

      const nodeLeft = node.x - nodeWidth / 2;
      const nodeRight = node.x + nodeWidth / 2;
      const nodeTop = node.y - nodeHeight / 2;
      const nodeBottom = node.y + nodeHeight / 2;
      //console.log('nodeleft', nodeLeft, 'nodeRight', nodeRight, 'nodeTop', nodeTop, 'nodeBottom', nodeBottom );
      nodesAll = attrs.allNodes;
      // Compare with all other nodes to check for overlap
      /*nodesAll.forEach((otherNode, otherIndex) => {
        setTimeout(() => {
          if (otherNode.x) {
            //console.log('otherNode', otherNode, otherNode.x , otherNode.y,otherNode.id,  otherNode.depth);
            const nodeCopy = {
              x: otherNode.x,
              y: otherNode.y,
              id: otherNode.id,
              row: otherNode.row
              // Add other properties as needed, excluding circular ones like 'parent' or 'children'
            };
            //console.log('nodeCopy', nodeCopy.x, nodeCopy.y); 
          }
          if (node.id !== otherNode.id) {
            // Define boundaries of the other node
            const otherLeft = otherNode.x - nodeWidth / 2;
            const otherRight = otherNode.x + nodeWidth / 2;
            const otherTop = otherNode.y - nodeHeight / 2;
            const otherBottom = otherNode.y + nodeHeight / 2;
            // Check if nodes overlap horizontally and vertically
            const horizontalOverlap = !(nodeRight < otherLeft || nodeLeft > otherRight);
            const verticalOverlap = !(nodeBottom < otherTop || nodeTop > otherBottom);
            if (!isNaN(otherLeft)) {
              //console.log('horizontalOverlap', horizontalOverlap, 'verticalOverlap', verticalOverlap);
              //console.log('node.id', node.id, 'nodeleft', nodeLeft, 'nodeRight', nodeRight, 'nodeTop', nodeTop, 'nodeBottom', nodeBottom, 'node.x', node.x,'node.y', node.y, node );
      
              //console.log('otherNode.id', otherNode.id,'otherleft', otherLeft, 'otherRight', otherRight, 'otherTop', otherTop, 'otherBottom', otherBottom, 'otherNode.x', otherNode.x, 'otherNode.y', otherNode.y, otherNode );
              //console.log('node.id', node.id, 'node.x', node.x,'node.y', node.y,  'otherNode.id', otherNode.id, 'otherNode.x', otherNode.x, 'otherNode.y', otherNode.y);
                  
              // If overlap is detected, adjust the position of the current node
              if (horizontalOverlap && verticalOverlap) {
                console.log('matched');
                // Resolve the overlap by shifting the current node (you can modify this logic)
                // Move the node down by the node height + padding
                //node.y += node.y + 100;
              
                // Optionally, move the node horizontally as well
                //node.x += node.x + 100;
      
                // Update the tempNodeChildSave after adjusting position
                /*tempNodeChildSave[node.id] = {
                  parentId: node.parent.id,
                  id: node.id,
                  x: node.x,
                  y: node.y,
                  width: nodeWidth.toString(),
                  nodeSelf: node,
                };
              }
            }
          }
        }, otherIndex * 500); // Adding a 500ms delay for each iteration
      });
       // Closing the forEach loop
      

      // If the node has children, recursively update them as well
      if (node.children && node.children.length > 0) {
          node.children.forEach(child => updateChildCoordinates(child)); // Recursion for each child
      }
    }
    
    chart.update = function({ x0, y0, x = 0, y = 0, width, height }) {
      const attrs = this.getChartState();
      const calc = attrs.calc;

      // Paging
      if (attrs.compact) {
        chart.calculateCompactFlexDimensions(attrs.root);
      }

      //  Assigns the x and y position for the nodes
      const treeData = attrs.flexTreeLayout(attrs.root);
      
      if (treeData.id === node_secondry.id) {
        treeData.x = node_main.x;    // Update x
        treeData.y = node_main.y;    // Update y
        treeData.x0 = node_main.x;   // Update x0
        treeData.y0 = node_main.y;   // Update y0
        tempNodeChildSave[node_main.subject.id] = {
          parentId: node_main.subject.id,
          id:node_main.subject.id,
          x: node_main.x,
          y: node_main.y,
          width: '222',
          nodeSelf: node,
        };
      }
    
      if (treeData['children'] && treeData['children'].length > 0) {
        treeData['children'].forEach((child, index) => {
          setTimeout(() => {
            updateChildCoordinates(child);
          }, index * 500); // Adding a 500ms delay for each child
        });
      }
      

      //console.log('treeData', treeData);
      // Reassigns the x and y position for the based on the compact layout
      if (attrs.compact) {
        calculateCompactFlexPositions(attrs.root);
      }

      const nodes = treeData.descendants();

      // //console.table(nodes.map(d => ({ x: d.x, y: d.y, width: d.width, height: d.height, flexCompactDim: d.flexCompactDim + "" })))

      // Get all links
      const links = treeData.descendants().slice(1);
      nodes.forEach(attrs.layoutBindings[attrs.layout].swap)

      // Connections
      const connections = attrs.connections;
      const allNodesMap = {};
      attrs.allNodes.forEach(d => allNodesMap[attrs.nodeId(d.data)] = d);

      const visibleNodesMap = {}
      nodes.forEach(d => visibleNodesMap[attrs.nodeId(d.data)] = d);

      connections.forEach(connection => {
          const source = allNodesMap[connection.from];
          const target = allNodesMap[connection.to];
          connection._source = source;
          connection._target = target;
      })
      const visibleConnections = connections.filter(d => visibleNodesMap[d.from] && visibleNodesMap[d.to]);
      const defsString = attrs.defs.bind(this)(attrs, visibleConnections);
      const existingString = attrs.defsWrapper.html();
      if (defsString !== existingString) {
          attrs.defsWrapper.html(defsString)
      }

      // --------------------------  LINKS ----------------------
      // Get links selection
      const linkSelection = attrs.linksWrapper
          .selectAll("path.link")
          .data(links, (d) => attrs.nodeId(d.data));

      // Enter any new links at the parent's previous position.
      const linkEnter = linkSelection
          .enter()
          .insert("path", "g")
          .attr("class", "link")
          .attr("d", (d) => {
              const xo = attrs.layoutBindings[attrs.layout].linkJoinX({ x: x0, y: y0, width, height });
              const yo = attrs.layoutBindings[attrs.layout].linkJoinY({ x: x0, y: y0, width, height });
              const o = { x: xo, y: yo };
              return attrs.layoutBindings[attrs.layout].diagonal(o, o, o);
          });

      // Get links update selection
      const linkUpdate = linkEnter.merge(linkSelection);

      // Styling links
      linkUpdate
          .attr("fill", "none")


      if (this.isEdge()) {
          linkUpdate
              .style('display', d => {
                  const display = d.data._pagingButton ? 'none' : 'auto'
                  return display;
              })
      } else {
          linkUpdate
              .attr('display', d => {
                  const display = d.data._pagingButton ? 'none' : 'auto'
                  return display;
              })
      }

      // Allow external modifications
      linkUpdate.each(attrs.linkUpdate);

      // Transition back to the parent element position
      linkUpdate
          .transition()
          .duration(attrs.duration)
          .attr("d", (d) => {
              const n = attrs.compact && d.flexCompactDim ?
                  {
                      x: attrs.layoutBindings[attrs.layout].compactLinkMidX(d, attrs),
                      y: attrs.layoutBindings[attrs.layout].compactLinkMidY(d, attrs)
                  } :
                  {
                      x: attrs.layoutBindings[attrs.layout].linkX(d),
                      y: attrs.layoutBindings[attrs.layout].linkY(d)
                  };

              const p = {
                  x: attrs.layoutBindings[attrs.layout].linkParentX(d),
                  y: attrs.layoutBindings[attrs.layout].linkParentY(d),
              };

              const m = attrs.compact && d.flexCompactDim ? {
                  x: attrs.layoutBindings[attrs.layout].linkCompactXStart(d),
                  y: attrs.layoutBindings[attrs.layout].linkCompactYStart(d),
              } : n;
              return attrs.layoutBindings[attrs.layout].diagonal(n, p, m, { sy: attrs.linkYOffset });
          });

      // Remove any  links which is exiting after animation
      const linkExit = linkSelection
          .exit()
          .transition()
          .duration(attrs.duration)
          .attr("d", (d) => {
              const xo = attrs.layoutBindings[attrs.layout].linkJoinX({ x, y, width, height });
              const yo = attrs.layoutBindings[attrs.layout].linkJoinY({ x, y, width, height });
              const o = { x: xo, y: yo };
              return attrs.layoutBindings[attrs.layout].diagonal(o, o, null, { sy: attrs.linkYOffset });
          })
          .remove();


      // --------------------------  CONNECTIONS ----------------------

      const connectionsSel = attrs.connectionsWrapper
          .selectAll("path.connection")
          .data(visibleConnections)

      // Enter any new connections at the parent's previous position.
      const connEnter = connectionsSel
          .enter()
          .insert("path", "g")
          .attr("class", "connection")
          .attr("d", (d) => {
              const xo = attrs.layoutBindings[attrs.layout].linkJoinX({ x: x0, y: y0, width, height });
              const yo = attrs.layoutBindings[attrs.layout].linkJoinY({ x: x0, y: y0, width, height });
              const o = { x: xo, y: yo };
              return attrs.layoutBindings[attrs.layout].diagonal(o, o, null, { sy: attrs.linkYOffset });
          });


      // Get connections update selection
      const connUpdate = connEnter.merge(connectionsSel);

      // Styling connections
      connUpdate.attr("fill", "none")

      // Transition back to the parent element position
      connUpdate
          .transition()
          .duration(attrs.duration)
          .attr('d', (d) => {
              const xs = attrs.layoutBindings[attrs.layout].linkX({ x: d._source.x, y: d._source.y, width: d._source.width, height: d._source.height });
              const ys = attrs.layoutBindings[attrs.layout].linkY({ x: d._source.x, y: d._source.y, width: d._source.width, height: d._source.height });
              const xt = attrs.layoutBindings[attrs.layout].linkJoinX({ x: d._target.x, y: d._target.y, width: d._target.width, height: d._target.height });
              const yt = attrs.layoutBindings[attrs.layout].linkJoinY({ x: d._target.x, y: d._target.y, width: d._target.width, height: d._target.height });
              return attrs.linkGroupArc({ source: { x: xs, y: ys }, target: { x: xt, y: yt } })
          })

      // Allow external modifications
      connUpdate.each(attrs.connectionsUpdate);

      // Remove any  links which is exiting after animation
      const connExit = connectionsSel
          .exit()
          .transition()
          .duration(attrs.duration)
          .attr('opacity', 0)
          .remove();

      // --------------------------  NODES ----------------------
      // Get nodes selection
      const nodesSelection = attrs.nodesWrapper
          .selectAll("g.node")
          .data(nodes, ({ data }) => attrs.nodeId(data));

      // Enter any new nodes at the parent's previous position.
      const nodeEnter = nodesSelection
          .enter()
          .append("g")
          .attr("class", "node")
          .attr("transform", (d) => {
              if (d == attrs.root) return `translate(${x0},${y0})`
              const xj = attrs.layoutBindings[attrs.layout].nodeJoinX({ x: x0, y: y0, width, height });
              const yj = attrs.layoutBindings[attrs.layout].nodeJoinY({ x: x0, y: y0, width, height });
              return `translate(${xj},${yj})`
          })
          .attr("cursor", "pointer")
          .on("click.node", (event, node) => {
              const { data } = node;
              if ([...event.srcElement.classList].includes("node-button-foreign-object")) {
                  return;
              }
              if ([...event.srcElement.classList].includes("paging-button-wrapper")) {
                  this.loadPagingNodes(node);
                  return;
              }
              if (!data._pagingButton) {
                  attrs.onNodeClick(node);
                  return;
              }
              //console.log('event fired, no handlers')
          })
          //  Event handler to the expand button
          .on("keydown.node", (event, node) => {
              const { data } = node;
              if (event.key === 'Enter' || event.key === ' ' || event.key === 'Spacebar') {
                  if ([...event.srcElement.classList].includes("node-button-foreign-object")) {
                      return;
                  }
                  if ([...event.srcElement.classList].includes("paging-button-wrapper")) {
                      this.loadPagingNodes(node);
                      return;
                  }
                  if (event.key === 'Enter' || event.key === ' ' || event.key === 'Spacebar') {
                      this.onButtonClick(event, node)
                  }
              }
          });
      nodeEnter.each(attrs.nodeEnter)

      // Add background rectangle for the nodes
      nodeEnter
          .patternify({
              tag: "rect",
              selector: "node-rect",
              data: (d) => [d]
          })

      // Node update styles
      const nodeUpdate = nodeEnter
          .merge(nodesSelection)
          .style("font", "12px sans-serif");

      // Add foreignObject element inside rectangle
      const fo = nodeUpdate.patternify({
          tag: "foreignObject",
          selector: "node-foreign-object",
          data: (d) => [d]
      })
          .style('overflow', 'visible')

      // Add foreign object
      fo.patternify({
          tag: "xhtml:div",
          selector: "node-foreign-object-div",
          data: (d) => [d]
      })

      this.restyleForeignObjectElements();

      // Add Node button circle's group (expand-collapse button)
      const nodeButtonGroups = nodeEnter
          .patternify({
              tag: "g",
              selector: "node-button-g",
              data: (d) => [d]
          })
          .on("click", (event, d) => this.onButtonClick(event, d))
          .on("keydown", (event, d) => {
              if (event.key === 'Enter' || event.key === ' ' || event.key === 'Spacebar') {
                  this.onButtonClick(event, d)
              }
          });

      nodeButtonGroups.patternify({
          tag: 'rect',
          selector: 'node-button-rect',
          data: (d) => [d]
      })
          .attr('opacity', 0)
          .attr('pointer-events', 'all')
          .attr('width', d => attrs.nodeButtonWidth(d))
          .attr('height', d => attrs.nodeButtonHeight(d))
          .attr('x', d => attrs.nodeButtonX(d))
          .attr('y', d => attrs.nodeButtonY(d))

      // Add expand collapse button content
      const nodeFo = nodeButtonGroups
          .patternify({
              tag: "foreignObject",
              selector: "node-button-foreign-object",
              data: (d) => [d]
          })
          .attr('width', d => attrs.nodeButtonWidth(d))
          .attr('height', d => attrs.nodeButtonHeight(d))
          .attr('x', d => attrs.nodeButtonX(d))
          .attr('y', d => attrs.nodeButtonY(d))
          .style('overflow', 'visible')
          .patternify({
              tag: "xhtml:div",
              selector: "node-button-div",
              data: (d) => [d]
          })
          .style('pointer-events', 'none')
          .style('display', 'flex')
          .style('width', '100%')
          .style('height', '100%')



      // Transition to the proper position for the node
      nodeUpdate
          .transition()
          .attr("opacity", 0)
          .duration(attrs.duration)
          .attr("transform", ({ x, y, width, height }) => {
              return attrs.layoutBindings[attrs.layout].nodeUpdateTransform({ x, y, width, height });

          })
          .attr("opacity", 1);

      // Style node rectangles
      nodeUpdate
          .select(".node-rect")
          .attr("width", ({ width }) => width)
          .attr("height", ({ height }) => height)
          .attr("x", ({ width }) => 0)
          .attr("y", ({ height }) => 0)
          .attr("cursor", "pointer")
          .attr('rx', 3)
          .attr("fill", attrs.nodeDefaultBackground)


      nodeUpdate.select(".node-button-g").attr("transform", ({ data, width, height }) => {
          const x = attrs.layoutBindings[attrs.layout].buttonX({ width, height });
          const y = attrs.layoutBindings[attrs.layout].buttonY({ width, height });
          return `translate(${x},${y})`
      })
          .attr("display", ({ data }) => {
              return data._directSubordinates > 0 ? null : 'none';
          })
          .attr("opacity", ({ data, children, _children }) => {
              if (data._pagingButton) {
                  return 0;
              }
              if (children || _children) {
                  return 1;
              }
              return 0;
          });

      // Restyle node button circle
      nodeUpdate
          .select(".node-button-foreign-object .node-button-div")
          .html((node) => {
              return attrs.buttonContent({ node, state: attrs })
          })

      // Restyle button texts
      nodeUpdate
          .select(".node-button-text")
          .attr("text-anchor", "middle")
          .attr("alignment-baseline", "middle")
          .attr("font-size", ({ children }) => {
              if (children) return 40;
              return 26;
          })
          .text(({ children }) => {
              if (children) return "-";
              return "+";
          })
          .attr("y", this.isEdge() ? 10 : 0);

      nodeUpdate.each(attrs.nodeUpdate)

      // Remove any exiting nodes after transition
      const nodeExitTransition = nodesSelection
          .exit()
      nodeExitTransition.each(attrs.nodeExit)

      const maxDepthNode = nodeExitTransition.data().reduce((a, b) => a.depth < b.depth ? a : b, { depth: Infinity });

      nodeExitTransition.attr("opacity", 1)
          .transition()
          .duration(attrs.duration)
          .attr("transform", (d) => {

              let { x, y, width, height } = maxDepthNode.parent || {};
              const ex = attrs.layoutBindings[attrs.layout].nodeJoinX({ x, y, width, height });
              const ey = attrs.layoutBindings[attrs.layout].nodeJoinY({ x, y, width, height });
              return `translate(${ex},${ey})`
          })
          .on("end", function () {
              d3.select(this).remove();
          })
          .attr("opacity", 0);

      // Store the old positions for transition.
      nodes.forEach((d) => {
          d.x0 = d.x;
          d.y0 = d.y;
      });

      // CHECK FOR CENTERING
      const centeredNode = attrs.allNodes.filter(d => d.data._centered)[0]
      if (centeredNode) {
          let centeredNodes = [centeredNode]
          if (centeredNode.data._centeredWithDescendants) {
              if (attrs.compact) {
                  centeredNodes = centeredNode.descendants().filter((d, i) => i < 7);
              } else {
                  centeredNodes = centeredNode.descendants().filter((d, i, arr) => {
                      const h = Math.round(arr.length / 2);
                      const spread = 2;
                      if (arr.length % 2) {
                          return i > h - spread && i < h + spread - 1;
                      }

                      return i > h - spread && i < h + spread;
                  });
              }

          }
          centeredNode.data._centeredWithDescendants = null;
          centeredNode.data._centered = null;
          this.fit({
              animate: true,
              scale: false,
              nodes: centeredNodes
          })
      }

    }*/

    function checkOverlap(node) {
      const attrs = chart.getChartState();
      const nodeWidth = 222; // Fixed width for nodes
      const nodeHeight = 110; // Fixed height for nodes
      const padding = 10; // Padding between nodes to avoid overlap
  
      let nodeLeft, nodeRight, nodeTop, nodeBottom;
  
      if (tempNodeChildSave[node.id]) {
          nodeLeft = tempNodeChildSave[node.id].x - nodeWidth / 2;
          nodeRight = tempNodeChildSave[node.id].x + nodeWidth / 2;
          nodeTop = tempNodeChildSave[node.id].y - nodeHeight / 2;
          nodeBottom = tempNodeChildSave[node.id].y + nodeHeight / 2;
      } else {
          nodeLeft = node.x - nodeWidth / 2;
          nodeRight = node.x + nodeWidth / 2;
          nodeTop = node.y - nodeHeight / 2;
          nodeBottom = node.y + nodeHeight / 2;
      }
  
      //console.log(nodeLeft, nodeRight, nodeTop, nodeBottom);
  
      const nodesAll = attrs.allNodes;
      let overlapInfo = { isOverlapping: false, direction: null };
  
      nodesAll.forEach((otherNode) => {
        if (otherNode.id !== node.id && otherNode.y) {
          // Define boundaries of the other node
          const otherLeft = otherNode.x - nodeWidth / 2;
          const otherRight = otherNode.x + nodeWidth / 2;
          const otherTop = otherNode.y - nodeHeight / 2;
          const otherBottom = otherNode.y + nodeHeight / 2;

          // Check for overlap
          const horizontalOverlap = !(nodeRight < otherLeft || nodeLeft > otherRight);
          const verticalOverlap = !(nodeBottom < otherTop || nodeTop > otherBottom);

          if (horizontalOverlap && verticalOverlap) {
            //console.log('matched');
            overlapInfo.isOverlapping = true;

            // Determine overlap direction
            if (nodeRight > otherLeft && nodeLeft < otherLeft) {
              overlapInfo.direction = 'left'; // Node overlaps on the left
            } else if (nodeLeft < otherRight && nodeRight > otherRight) {
              overlapInfo.direction = 'right'; // Node overlaps on the right
            }
          }
        }
      });
  
      return overlapInfo;
    }

    function checkOverlapChild(node) {
      const attrs = chart.getChartState();
      const nodeWidth = 222; // Fixed width for nodes
      const nodeHeight = 110; // Fixed height for nodes
      const padding = 10; // Padding between nodes to avoid overlap
  
      let nodeLeft, nodeRight, nodeTop, nodeBottom;
      let nodeX = tempNodeChildSave[node_main.id];
      //console.log('nodeX', nodeX);
      let nodeY;
      if(node.compactEven === true){
        nodeX -= 126;
      }else if((node.compactEven === false)){
        nodeX += 126;
      }
      //console.log('after nodeX', nodeX);
      // Count children of this parent node (using the childCount dictionary)
      if (!tempChildCount[node.parent.id]) {
        tempChildCount[node.parent.id] = 1; // Initialize counter for the parent

        // Initialize value for y-position based on the parent's y-coordinate
        tempChildCount['value'] = tempNodeChildSave[node.parent.id].y + 30;  // Start the first child below the parent
      }

      if (tempChildCount[node.parent.id] % 2 === 0) {
        // Even-indexed children stay on the same y-level as previous odd child
        nodeY = tempChildCount['value'];  // Use saved value
      } else {
        // Odd-indexed children move to the next row (150 units lower)
        nodeY = tempChildCount['value'] + 150;
        
        // Update the saved 'value' for even children
        tempChildCount['value'] = nodeY;
      }

      // Increment the child count for this parent after placing the child
      tempChildCount[node.parent.id] += 1;
      

      
      nodeLeft = nodeX - nodeWidth / 2;
      nodeRight = nodeX + nodeWidth / 2;
      nodeTop = nodeY - nodeHeight / 2;
      nodeBottom = nodeY + nodeHeight / 2;
  
  
      //console.log(nodeLeft, nodeRight, nodeTop, nodeBottom);
  
      const nodesAll = attrs.allNodes;
      let overlapInfo = { isOverlapping: false, direction: null };
  
      nodesAll.forEach((otherNode) => {
        if (otherNode.id !== node.id && otherNode.y) {
          // Define boundaries of the other node
          const otherLeft = otherNode.x - nodeWidth / 2;
          const otherRight = otherNode.x + nodeWidth / 2;
          const otherTop = otherNode.y - nodeHeight / 2;
          const otherBottom = otherNode.y + nodeHeight / 2;
          //console.log('nodeRight', nodeRight, 'nodeLeft', nodeLeft, 'otherLeft', otherLeft, 'otherRight', otherRight, 'node.id', node.id, 'node', node, 'node.x', node.x,'otherNode', otherNode, 'otherNode.id', otherNode.id, 'otherNode.x', otherNode.x);

          // Check for overlap
          const horizontalOverlap = !(nodeRight < otherLeft || nodeLeft > otherRight);
          const verticalOverlap = !(nodeBottom < otherTop || nodeTop > otherBottom);

          if (horizontalOverlap && verticalOverlap) {
            //console.log('matched2');
            overlapInfo.isOverlapping = true;
            // Determine overlap direction
            if (nodeRight > otherLeft && nodeLeft < otherLeft) {
              overlapInfo.direction = 'left'; // Node overlaps on the left
            } else if (nodeLeft < otherRight && nodeRight > otherRight) {
              overlapInfo.direction = 'right'; // Node overlaps on the right
            }
          }
        }
      });
  
      return overlapInfo;
    }
    // Calculate the leftmost and rightmost neighbors (siblings) for the parent
    function findExtremeXValues() {
      let leftMostX = Infinity;
      let rightMostX = -Infinity;
      const attrs = chart.getChartState();
      // Iterate over all nodes to find extreme x values
      attrs.root.children.forEach(child => {
          if (child.x < leftMostX) {
              leftMostX = child.x; // Leftmost child
          }
          if (child.x > rightMostX) {
              rightMostX = child.x; // Rightmost child
          }
      });

      return { leftMostX, rightMostX };
    }

    

    // Recursive function to traverse through children and update their x and y values
    function updateChildCoordinates(node) {
      //console.log('node', node, node.x, node.y, node.id);

      if(node.data.id === node_secondry.id){
        let overlapInfo = checkOverlap(node);
        let nodeX = node_main.x;
        let nodeY = node_main.y;
        let childOverlapInfo;
        /*
        while (overlapInfo.isOverlapping) {
          // Adjust node's position based on overlap direction
          if (overlapInfo.direction === 'right') {
              nodeX += 200; // Move the node to the right
          } else if (overlapInfo.direction === 'left') {
              nodeX -= 200; // Move the node to the left
          }

          // Update node's position
          node.x = nodeX;
          node.y = nodeY; // Keep y same as node_main.y
          node.x0 = nodeX;
          node.y0 = nodeY;

          tempNodeChildSave[node_secondry.id] = {
            parentId: node_secondry.parent.id,
            id:node_secondry.id,
            x: nodeX,
            y: node_main.y,
            width: '222',
            nodeSelf: node,
          };

          // Re-check for overlap
          overlapInfo = checkOverlap(node);
          //console.log('Updated overlapInfo', overlapInfo);
        }
        const attrs = chart.getChartState();
        
        
        //Check overlap for all children nodes
        if (node.children && node.children.length > 0) {
          console.log('go');
          for (let i = 0; i < node.children.length; i++) {
            const childNode = node.children[i];
            //Check overlap for the child
            childOverlapInfo = checkOverlapChild(childNode);
            if (childOverlapInfo.isOverlapping) {
              break; // Exit the loop if overlap is found
            }
          }
          tempChildCount = {};
        }
        
        if(childOverlapInfo){
          if(childOverlapInfo.isOverlapping){
            // Calculate the extreme x positions of siblings/children
            const { leftMostX, rightMostX } = findExtremeXValues(node);
            console.log('Leftmost X:', leftMostX, 'Rightmost X:', rightMostX);

            // Compare absolute values to find which one is farther from 0
            if (Math.abs(rightMostX) > Math.abs(leftMostX)) {
              // Right side is farther, so move the parent node to the right
              nodeX = rightMostX + 400; // Adjust this value as needed
              console.log('Moving node to the right');
            } else {
              // Left side is farther, so move the parent node to the left
              nodeX = rightMostX - 200; // Adjust this value as needed
              console.log('Moving node to the left');
            }
          }
        }
        
        console.log('childOverlapInfo2', childOverlapInfo);
        //console.log('node condition', node.x, node.y, node.id, node_secondry.id)
        tempNodeChildSave[node_secondry.id] = {
          parentId: node_secondry.parent.id,
          id:node_secondry.id,
          x: nodeX,
          y: node_main.y,
          width: '222',
          nodeSelf: node,
        };*/

        node.x = node_main.x; // Update x
        node.y = node_main.y; // Update y
        node.x0 = node_main.x; // Update x0
        node.y0 = node_main.y; // Update y0

        tempNodeChildSave[node_secondry.id] = {
          parentId: node_secondry.parent.id,
          id:node_secondry.id,
          x: node_main.x,
          y: node_main.y,
          width: '222',
          nodeSelf: node,
        };
      }

      // Check if the current node's ID exists in tempNodeChildSave
      if (tempNodeChildSave[node.data.id]) {
        // Get predefined values for that node ID
        const predefinedValues = tempNodeChildSave[node.data.id];
        // Update the x and y values based on predefined values
        //console.log(`Before Update - Node ID: ${node.data.id}, X: ${node.x}, Y: ${node.y}`);
        node.x = predefinedValues.x; // Update x
        node.y = predefinedValues.y; // Update y
        node.x0 = predefinedValues.x; // Update x0
        node.y0 = predefinedValues.y; // Update y0
        //console.log(`After Update - Node ID: ${node.data.id}, New X: ${node.x}, New Y: ${node.y}`);
      }

      if(node.parent.id === node_secondry.id){
        let nodeX = node.parent.x;
        let nodeY;
        if(node.compactEven === true){
          nodeX -= 126;
        }else if((node.compactEven === false)){
          nodeX += 126;
        }

        // Count children of this parent node (using the childCount dictionary)
        if (!childCount[node.parent.id]) {
          childCount[node.parent.id] = 1; // Initialize counter for the parent

          // Initialize value for y-position based on the parent's y-coordinate
          childCount['value'] = node.parent.y + 30;  // Start the first child below the parent
        }

        if (childCount[node.parent.id] % 2 === 0) {
          // Even-indexed children stay on the same y-level as previous odd child
          nodeY = childCount['value'];  // Use saved value
        } else {
          // Odd-indexed children move to the next row (150 units lower)
          nodeY = childCount['value'] + 150;
          
          // Update the saved 'value' for even children
          childCount['value'] = nodeY;
        }

        // Increment the child count for this parent after placing the child
        childCount[node.parent.id] += 1;
        

        // Update node's position
        node.x = nodeX;
        node.y = nodeY; // Keep y same as node_main.y
        node.x0 = nodeX;
        node.y0 = nodeY;

        tempNodeChildSave[node.id] = {
          parentId: node.parent.id,
          id:node.id,
          x: nodeX,
          y: nodeY,
          width: '222',
          nodeSelf: node,
        };

      }

      //console.log('predefined', tempNodeChildSave);

      // If the node has children, recursively update them as well
      if (node.children && node.children.length > 0) {
          node.children.forEach(child => updateChildCoordinates(child)); // Recursion for each child
      }

    }

    chart.update = function({ x0, y0, x = 0, y = 0, width, height }) {
      const attrs = this.getChartState();
      const calc = attrs.calc;

      // Paging
      if (attrs.compact) {
          this.calculateCompactFlexDimensions(attrs.root);
      }

      //  Assigns the x and y position for the nodes
      const treeData = attrs.flexTreeLayout(attrs.root);
      
      if (treeData.id === node_secondry.id) {
        treeData.x = node_main.x;    // Update x
        treeData.y = node_main.y;    // Update y
        treeData.x0 = node_main.x;   // Update x0
        treeData.y0 = node_main.y;   // Update y0
        /*tempNodeChildSave[node_main.subject.id] = {
          parentId: node_main.subject.id,
          id:node_main.subject.id,
          x: node_main.x,
          y: node_main.y,
          width: '222',
          nodeSelf: node,
        };*/
      }
    

      

      //console.log('treeData', treeData);
      // Reassigns the x and y position for the based on the compact layout
      if (attrs.compact) {
        calculateCompactFlexPositions(attrs.root);
      }

      if (treeData['children'] && treeData['children'].length > 0) {
         // Initialize or increment the count for the current node id
        if (!checkExpandCollapse[node_main.id]) {
          checkExpandCollapse[node_main.id] = 1; // Initialize with 1 if not already set
          treeData['children'].forEach((child) => {
            //setTimeout(() => {
              //console.log('before child', child, child['x'], child.y, child.id);
              updateChildCoordinates(child);
              //console.log('after child', child, child.x, child.y, child.id);
            //}, 50);
          });
        } else {
          checkExpandCollapse[node_main.id] += 1; // Increment by 1 if it already exists
          tempNodeChildSave = {};
          attrs.allNodes.forEach(node => {
            if(node.id !== '100'){
              console.log(node.id, node);
              //updateChildCoordinates(node);
            }
            if (node.id === node_secondry.id) {
              if(node.children){
                console.log('node is expand', tempNodeChildSave);
              }else{
                console.log('node is collapsed', tempNodeChildSave);
              }
            }
          });
        }
        console.log('checkExpandCollapse',checkExpandCollapse[node_main.id]);
        
        // After the loop, clear the child count dictionary for future use
        childCount = {};
      }

      const nodes = treeData.descendants();

      // //console.table(nodes.map(d => ({ x: d.x, y: d.y, width: d.width, height: d.height, flexCompactDim: d.flexCompactDim + "" })))

      // Get all links
      const links = treeData.descendants().slice(1);
      nodes.forEach(attrs.layoutBindings[attrs.layout].swap)

      // Connections
      const connections = attrs.connections;
      const allNodesMap = {};
      attrs.allNodes.forEach(d => allNodesMap[attrs.nodeId(d.data)] = d);

      const visibleNodesMap = {}
      nodes.forEach(d => visibleNodesMap[attrs.nodeId(d.data)] = d);

      connections.forEach(connection => {
          const source = allNodesMap[connection.from];
          const target = allNodesMap[connection.to];
          connection._source = source;
          connection._target = target;
      })
      const visibleConnections = connections.filter(d => visibleNodesMap[d.from] && visibleNodesMap[d.to]);
      const defsString = attrs.defs.bind(this)(attrs, visibleConnections);
      const existingString = attrs.defsWrapper.html();
      if (defsString !== existingString) {
          attrs.defsWrapper.html(defsString)
      }

      // --------------------------  LINKS ----------------------
      // Get links selection
      const linkSelection = attrs.linksWrapper
          .selectAll("path.link")
          .data(links, (d) => attrs.nodeId(d.data));

      // Enter any new links at the parent's previous position.
      const linkEnter = linkSelection
          .enter()
          .insert("path", "g")
          .attr("class", "link")
          .attr("d", (d) => {
              const xo = attrs.layoutBindings[attrs.layout].linkJoinX({ x: x0, y: y0, width, height });
              const yo = attrs.layoutBindings[attrs.layout].linkJoinY({ x: x0, y: y0, width, height });
              const o = { x: xo, y: yo };
              return attrs.layoutBindings[attrs.layout].diagonal(o, o, o);
          });

      // Get links update selection
      const linkUpdate = linkEnter.merge(linkSelection);

      // Styling links
      linkUpdate
          .attr("fill", "none")


      if (this.isEdge()) {
          linkUpdate
              .style('display', d => {
                  const display = d.data._pagingButton ? 'none' : 'auto'
                  return display;
              })
      } else {
          linkUpdate
              .attr('display', d => {
                  const display = d.data._pagingButton ? 'none' : 'auto'
                  return display;
              })
      }

      // Allow external modifications
      linkUpdate.each(attrs.linkUpdate);

      // Transition back to the parent element position
      linkUpdate
          .transition()
          .duration(attrs.duration)
          .attr("d", (d) => {
              const n = attrs.compact && d.flexCompactDim ?
                  {
                      x: attrs.layoutBindings[attrs.layout].compactLinkMidX(d, attrs),
                      y: attrs.layoutBindings[attrs.layout].compactLinkMidY(d, attrs)
                  } :
                  {
                      x: attrs.layoutBindings[attrs.layout].linkX(d),
                      y: attrs.layoutBindings[attrs.layout].linkY(d)
                  };

              const p = {
                  x: attrs.layoutBindings[attrs.layout].linkParentX(d),
                  y: attrs.layoutBindings[attrs.layout].linkParentY(d),
              };

              const m = attrs.compact && d.flexCompactDim ? {
                  x: attrs.layoutBindings[attrs.layout].linkCompactXStart(d),
                  y: attrs.layoutBindings[attrs.layout].linkCompactYStart(d),
              } : n;
              return attrs.layoutBindings[attrs.layout].diagonal(n, p, m, { sy: attrs.linkYOffset });
          });

      // Remove any  links which is exiting after animation
      const linkExit = linkSelection
          .exit()
          .transition()
          .duration(attrs.duration)
          .attr("d", (d) => {
              const xo = attrs.layoutBindings[attrs.layout].linkJoinX({ x, y, width, height });
              const yo = attrs.layoutBindings[attrs.layout].linkJoinY({ x, y, width, height });
              const o = { x: xo, y: yo };
              return attrs.layoutBindings[attrs.layout].diagonal(o, o, null, { sy: attrs.linkYOffset });
          })
          .remove();


      // --------------------------  CONNECTIONS ----------------------

      const connectionsSel = attrs.connectionsWrapper
          .selectAll("path.connection")
          .data(visibleConnections)

      // Enter any new connections at the parent's previous position.
      const connEnter = connectionsSel
          .enter()
          .insert("path", "g")
          .attr("class", "connection")
          .attr("d", (d) => {
              const xo = attrs.layoutBindings[attrs.layout].linkJoinX({ x: x0, y: y0, width, height });
              const yo = attrs.layoutBindings[attrs.layout].linkJoinY({ x: x0, y: y0, width, height });
              const o = { x: xo, y: yo };
              return attrs.layoutBindings[attrs.layout].diagonal(o, o, null, { sy: attrs.linkYOffset });
          });


      // Get connections update selection
      const connUpdate = connEnter.merge(connectionsSel);

      // Styling connections
      connUpdate.attr("fill", "none")

      // Transition back to the parent element position
      connUpdate
          .transition()
          .duration(attrs.duration)
          .attr('d', (d) => {
              const xs = attrs.layoutBindings[attrs.layout].linkX({ x: d._source.x, y: d._source.y, width: d._source.width, height: d._source.height });
              const ys = attrs.layoutBindings[attrs.layout].linkY({ x: d._source.x, y: d._source.y, width: d._source.width, height: d._source.height });
              const xt = attrs.layoutBindings[attrs.layout].linkJoinX({ x: d._target.x, y: d._target.y, width: d._target.width, height: d._target.height });
              const yt = attrs.layoutBindings[attrs.layout].linkJoinY({ x: d._target.x, y: d._target.y, width: d._target.width, height: d._target.height });
              return attrs.linkGroupArc({ source: { x: xs, y: ys }, target: { x: xt, y: yt } })
          })

      // Allow external modifications
      connUpdate.each(attrs.connectionsUpdate);

      // Remove any  links which is exiting after animation
      const connExit = connectionsSel
          .exit()
          .transition()
          .duration(attrs.duration)
          .attr('opacity', 0)
          .remove();

      // --------------------------  NODES ----------------------
      // Get nodes selection
      const nodesSelection = attrs.nodesWrapper
          .selectAll("g.node")
          .data(nodes, ({ data }) => attrs.nodeId(data));

      // Enter any new nodes at the parent's previous position.
      const nodeEnter = nodesSelection
          .enter()
          .append("g")
          .attr("class", "node")
          .attr("transform", (d) => {
              if (d == attrs.root) return `translate(${x0},${y0})`
              const xj = attrs.layoutBindings[attrs.layout].nodeJoinX({ x: x0, y: y0, width, height });
              const yj = attrs.layoutBindings[attrs.layout].nodeJoinY({ x: x0, y: y0, width, height });
              return `translate(${xj},${yj})`
          })
          .attr("cursor", "pointer")
          .on("click.node", (event, node) => {
              const { data } = node;
              if ([...event.srcElement.classList].includes("node-button-foreign-object")) {
                  return;
              }
              if ([...event.srcElement.classList].includes("paging-button-wrapper")) {
                  this.loadPagingNodes(node);
                  return;
              }
              if (!data._pagingButton) {
                  attrs.onNodeClick(node);
                  return;
              }
              //console.log('event fired, no handlers')
          })
          //  Event handler to the expand button
          .on("keydown.node", (event, node) => {
              const { data } = node;
              if (event.key === 'Enter' || event.key === ' ' || event.key === 'Spacebar') {
                  if ([...event.srcElement.classList].includes("node-button-foreign-object")) {
                      return;
                  }
                  if ([...event.srcElement.classList].includes("paging-button-wrapper")) {
                      this.loadPagingNodes(node);
                      return;
                  }
                  if (event.key === 'Enter' || event.key === ' ' || event.key === 'Spacebar') {
                      this.onButtonClick(event, node)
                  }
              }
          });
      nodeEnter.each(attrs.nodeEnter)

      // Add background rectangle for the nodes
      nodeEnter
          .patternify({
              tag: "rect",
              selector: "node-rect",
              data: (d) => [d]
          })

      // Node update styles
      const nodeUpdate = nodeEnter
          .merge(nodesSelection)
          .style("font", "12px sans-serif");

      // Add foreignObject element inside rectangle
      const fo = nodeUpdate.patternify({
          tag: "foreignObject",
          selector: "node-foreign-object",
          data: (d) => [d]
      })
          .style('overflow', 'visible')

      // Add foreign object
      fo.patternify({
          tag: "xhtml:div",
          selector: "node-foreign-object-div",
          data: (d) => [d]
      })

      this.restyleForeignObjectElements();

      // Add Node button circle's group (expand-collapse button)
      const nodeButtonGroups = nodeEnter
          .patternify({
              tag: "g",
              selector: "node-button-g",
              data: (d) => [d]
          })
          .on("click", (event, d) => this.onButtonClick(event, d))
          .on("keydown", (event, d) => {
              if (event.key === 'Enter' || event.key === ' ' || event.key === 'Spacebar') {
                  this.onButtonClick(event, d)
              }
          });

      nodeButtonGroups.patternify({
          tag: 'rect',
          selector: 'node-button-rect',
          data: (d) => [d]
      })
          .attr('opacity', 0)
          .attr('pointer-events', 'all')
          .attr('width', d => attrs.nodeButtonWidth(d))
          .attr('height', d => attrs.nodeButtonHeight(d))
          .attr('x', d => attrs.nodeButtonX(d))
          .attr('y', d => attrs.nodeButtonY(d))

      // Add expand collapse button content
      const nodeFo = nodeButtonGroups
          .patternify({
              tag: "foreignObject",
              selector: "node-button-foreign-object",
              data: (d) => [d]
          })
          .attr('width', d => attrs.nodeButtonWidth(d))
          .attr('height', d => attrs.nodeButtonHeight(d))
          .attr('x', d => attrs.nodeButtonX(d))
          .attr('y', d => attrs.nodeButtonY(d))
          .style('overflow', 'visible')
          .patternify({
              tag: "xhtml:div",
              selector: "node-button-div",
              data: (d) => [d]
          })
          .style('pointer-events', 'none')
          .style('display', 'flex')
          .style('width', '100%')
          .style('height', '100%')



      // Transition to the proper position for the node
      nodeUpdate
          .transition()
          .attr("opacity", 0)
          .duration(attrs.duration)
          .attr("transform", ({ x, y, width, height }) => {
              return attrs.layoutBindings[attrs.layout].nodeUpdateTransform({ x, y, width, height });

          })
          .attr("opacity", 1);

      // Style node rectangles
      nodeUpdate
          .select(".node-rect")
          .attr("width", ({ width }) => width)
          .attr("height", ({ height }) => height)
          .attr("x", ({ width }) => 0)
          .attr("y", ({ height }) => 0)
          .attr("cursor", "pointer")
          .attr('rx', 3)
          .attr("fill", attrs.nodeDefaultBackground)


      nodeUpdate.select(".node-button-g").attr("transform", ({ data, width, height }) => {
          const x = attrs.layoutBindings[attrs.layout].buttonX({ width, height });
          const y = attrs.layoutBindings[attrs.layout].buttonY({ width, height });
          return `translate(${x},${y})`
      })
          .attr("display", ({ data }) => {
              return data._directSubordinates > 0 ? null : 'none';
          })
          .attr("opacity", ({ data, children, _children }) => {
              if (data._pagingButton) {
                  return 0;
              }
              if (children || _children) {
                  return 1;
              }
              return 0;
          });

      // Restyle node button circle
      nodeUpdate
          .select(".node-button-foreign-object .node-button-div")
          .html((node) => {
              return attrs.buttonContent({ node, state: attrs })
          })

      // Restyle button texts
      nodeUpdate
          .select(".node-button-text")
          .attr("text-anchor", "middle")
          .attr("alignment-baseline", "middle")
          .attr("font-size", ({ children }) => {
              if (children) return 40;
              return 26;
          })
          .text(({ children }) => {
              if (children) return "-";
              return "+";
          })
          .attr("y", this.isEdge() ? 10 : 0);

      nodeUpdate.each(attrs.nodeUpdate)

      // Remove any exiting nodes after transition
      const nodeExitTransition = nodesSelection
          .exit()
      nodeExitTransition.each(attrs.nodeExit)

      const maxDepthNode = nodeExitTransition.data().reduce((a, b) => a.depth < b.depth ? a : b, { depth: Infinity });

      nodeExitTransition.attr("opacity", 1)
          .transition()
          .duration(attrs.duration)
          .attr("transform", (d) => {

              let { x, y, width, height } = maxDepthNode.parent || {};
              const ex = attrs.layoutBindings[attrs.layout].nodeJoinX({ x, y, width, height });
              const ey = attrs.layoutBindings[attrs.layout].nodeJoinY({ x, y, width, height });
              return `translate(${ex},${ey})`
          })
          .on("end", function () {
              d3.select(this).remove();
          })
          .attr("opacity", 0);

      // Store the old positions for transition.
      nodes.forEach((d) => {
          d.x0 = d.x;
          d.y0 = d.y;
      });

      // CHECK FOR CENTERING
      const centeredNode = attrs.allNodes.filter(d => d.data._centered)[0]
      if (centeredNode) {
          let centeredNodes = [centeredNode]
          if (centeredNode.data._centeredWithDescendants) {
              if (attrs.compact) {
                  centeredNodes = centeredNode.descendants().filter((d, i) => i < 7);
              } else {
                  centeredNodes = centeredNode.descendants().filter((d, i, arr) => {
                      const h = Math.round(arr.length / 2);
                      const spread = 2;
                      if (arr.length % 2) {
                          return i > h - spread && i < h + spread - 1;
                      }

                      return i > h - spread && i < h + spread;
                  });
              }

          }
          centeredNode.data._centeredWithDescendants = null;
          centeredNode.data._centered = null;
          this.fit({
              animate: true,
              scale: false,
              nodes: centeredNodes
          })
      }

    }

    checkExpandCollapse = {}

    let nodeData;
    let toAssignX;
    let toAssignY;
    let newX;
    let node_secondry;
    //console.log('original node', node_main);
    if (String(parameter) === "dragevent"){
      nodeData = data.find(x => String(x.id) === String(node_main.subject.id)); // Find the dropped node's data
      toAssignX = node_main.x;
      toAssignY = node_main.y;
      node_secondry = node_main.subject;
    }
    else{
      nodeData = data.find(x => String(x.id) === String(node_main.id)); // Find the dropped node's data
      node_secondry = node_main;
      toAssignX = dropX;
      toAssignY = dropY;
    }

    
    if (nodeData) {
      /*
      let tempDic = {};
      layout.top.nodeFlexSize = function({ height, width, siblingsMargin, childrenMargin, state, node, compactViewIndex }) {
        //console.log("nodeFlexSize", node.id, node.x);
        let result = [];
        if (state.compact && node.flexCompactDim) {
          if(node.id === '101'){
            result = [500, 400]
          }
          else{
            result = [node.flexCompactDim[0], node.flexCompactDim[1]]
          }
          //console.log('result', result);  
          return result;
        };
        //console.log('result2', [width + siblingsMargin, height + childrenMargin]);  
        if(node.id === '101'){
          return [800, 400];
        }
        else{
          return [width + siblingsMargin, height + childrenMargin];
        }
        
      };*/

      /*
      //work on drop & expand (only showing parent details)
      layout.top.linkJoinX = function(d) {
        //console.log("linkJoinX", d, nodeNewX);
        return d.x;
      };
      layout.top.linkJoinY = function(d) {
        //console.log("linkJoinY", d);
        return d.y + d.height; // Default behavior
      };*/
      
      //work on drop & expand
      layout.top.linkParentX = function(d) {
        ////console.log("linkParentX", d);
        
        return d.parent.x; // Default behavior
      };
      layout.top.linkParentY = function(d) {
        //console.log("linkParentY", d);
        if (node_secondry.parent && node_secondry.parent.y) {
          // If the parent exists and has a valid 'y' property
          if (node_secondry.parent.y > d.y) {
              //console.log('matched');
              return d.parent.y;  // Return the parent's 'y' value
          }
        }
        return d.parent.y + d.parent.height; // Default behavior
        
      };
      //work on drop & expand
      layout.top.linkX = function(d) {
        ////console.log("linkX", d, d.x);
        return d.x;
      };
      layout.top.linkY = function(d) {
        //console.log('linkY', d, d.y, node_main.y, node_secondry.parent.y);
        if(d.y <= node_secondry.parent.y && d.id === node_secondry.id){
          //console.log('met');
          return node_main.y + node_secondry.height;
        }
        return d.y;
      };

      /*
      layout.top.compactLinkMidX = function(node, state) {
        //console.log("compactLinkMidX", node, node.firstCompactNode.x + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4);
        if(node.id === node.parent.children[0].id){
          //console.log('lol');
          return node.parent.x;
        }
        return node.firstCompactNode.x + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4;
      };
      layout.top.compactLinkMidY = function(node) {
        //console.log("compactLinkMidY", node, node.firstCompactNode.y);
        return node.firstCompactNode.y;
      };
      */
      //work on drop & expand
      
      layout.top.linkCompactXStart = function(d) {
        // Retrieve chart attributes and layout information
        const attrs = chart.getChartState();
    
        // Get the CompactX value (middle point between siblings)
        const CompactX = attrs.layoutBindings[attrs.layout].compactLinkMidX(d, attrs);
    
        // Check if the d has been dragged to the opposite side of CompactX
        let finalCompact;
        // If the d is on the left of CompactX but should connect to the right (based on compactEven)
        if (CompactX < d.x && d.compactEven) {
          finalCompact = -d.width / 2;  // Attach to the left side of the d
        }
        // If the d is on the right of CompactX but should connect to the left (based on compactEven)
        else if (CompactX > d.x && !d.compactEven) {
            finalCompact = d.width / 2;  // Attach to the right side of the d
        } else {
            // Otherwise, use the default logic (based on compactEven value)
            finalCompact = d.compactEven ? d.width / 2 : -d.width / 2;
        }
        // Return the adjusted x position for the path attachment
        return d.x + finalCompact;
      };
    
      layout.top.linkCompactYStart = function(d) {
        ////console.log("linkCompactYStart", d, d.y + d.height / 2);
        return d.y + d.height / 2;
      };

      

      // work on expand
      /*layout.top.nodeJoinX = function(d) {
        //console.log("nodeJoinX", d, node.x - node.width / 2);
        return node.x - node.width / 2;

      };
      layout.top.nodeJoinY = function(d) {
        //console.log("nodeJoinY", d.y ,d.y + d.height);
        if(node_main.y >= node_main.subject.parent.y){
          //console.log('met');
          return node_main.y + node_main.subject.height;
        }
        return d.y + d.height;
      };*/

      /*
      // work on expand
      layout.top.nodeLeftX = function(d) {
        //console.log("nodeLeftX", d, nodeNewX, -d.width/2);
        return -d.width/2;
      };
      layout.top.nodeRightX = function(d) {
        //console.log("nodeRightX", d, nodeNewX, d.width/2);
        return d.width/2;
      };
      // work on expand
      layout.top.nodeTopY = function(d) {
        ////console.log("nodeTopY", d);
        return 0;
      };
      layout.top.nodeBottomY = function(d) {
        ////console.log("nodeBottomY", d);
        return d.height;
      };*/
      //work on drop & expand
      layout.top.compactLinkMidX = function(d, state) {
        //console.log("compactLinkMidX", d, state);
        ////console.log(d.firstCompactNode.x + d.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(d) / 4);
        return d.firstCompactNode.x + d.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(d) / 4;
      };
      layout.top.compactLinkMidY = function(d) {
        ////console.log("compactLinkMidY", d);
        ////console.log(d.firstCompactNode.y);
        return d.firstCompactNode.y;
      };
      /*
      //work on drop & expand
      layout.top.nodeUpdateTransform = function(d) {
        ////console.log("nodeUpdateTransform", d);
        const tolerance = 15;  // Define a small tolerance value
        // Check if d.x and node.subject.x are close enough
        if (Math.abs(d.x - node.x) <= tolerance && d.y === node.y) {
          if (d.x >= 0) {
            // For positive d.x
            newX = nodeNewX - d.x;
          } else {
            // For negative d.x
            newX = nodeNewX - Math.abs(d.x);
          }
          if (tempNodeSave[node.id]){
            if (d.x >= 0) {
              // For positive d.x
              newX = tempNodeSave[node.id].newX + newX;
            }
          }
          tempNodeSave[node.id] = {
            parentId: node.parent.data.id,
            id:node.id,
            x: d.x,
            y: node.y,
            width: '222',
            newX: newX,
            nodeSelf: d,
          };
          return `translate(${newX },${d.y})`;
        } else {
          // Retrieve and work with previously stored data
          for (const [id, savedData] of Object.entries(tempNodeSave)) {
            if (savedData.x === d.x && savedData.y === d.y) {
              return `translate(${savedData.newX}, ${d.y})`;
            }
          }
          return `translate(${d.x - node.width / 2}, ${d.y})`;
        }
      };

      

      //work on drop & expand
      /*layout.top.buttonX = function(d) {
        //console.log("buttonX", d);
        if (d.x === node.x && d.y === node.y) {
            return d.y; // Adjust as needed for specific cases
        } else {
            return d.y; // Default behavior
        }
      };
      layout.top.buttonY = function(d) {
        //console.log("buttonY", d);
        if (d.x === node.x && d.y === node.y) {
            return d.y; // Adjust as needed for specific cases
        } else {
            return d.y; // Default behavior
        }
      };
      

      chart.layoutBindings(layout);*/
      chart.render();
    } 
    
  }

  function enableDrag() {
    dragEnabled = true;
    document.querySelector('.chart-container').classList.add('drag-enabled');
    document.getElementById('enableDragButton').classList.add('hide');
    document.getElementById('dragActions').classList.remove('hide');
  }

  function disableDrag() {
    dragEnabled = false;
    document.querySelector('.chart-container').classList.remove('drag-enabled');
    document.getElementById('enableDragButton').classList.remove('hide');
    document.getElementById('dragActions').classList.add('hide');
    undoActions = [];
    redoActions = [];
    updateDragActions();
  }

  function cancelDrag() {
    if (undoActions.length === 0) {
      disableDrag();
      return;
    }

    const data = chart.getChartState().data;
    undoActions.reverse().forEach((action) => {
      const node = data.find((x) => String(x.id) === String(action.id));
      node.parentId = action.parentId;
    });

    disableDrag();
    chart.render();
  }

  function undo() {
    const action = undoActions.pop();
    if (action) {
      const node = chart.getChartState().data.find((x) => String(x.id) === String(action.id));
      const currentParentId = node.parentId;
      const previousParentId = action.parentId;
      action.parentId = currentParentId;
      node.parentId = previousParentId;

      redoActions.push(action);
      chart.render();
      updateDragActions();
    }
  }

  function redo() {
    const action = redoActions.pop();
    if (action) {
      const node = chart.getChartState().data.find((x) => String(x.id) === String(action.id));
      const currentParentId = node.parentId;
      const previousParentId = action.parentId;
      action.parentId = currentParentId;
      node.parentId = previousParentId;
      undoActions.push(action);
      chart.render();
      updateDragActions();
    }
  }

  function updateDragActions() {
    if (undoActions.length > 0) {
      const undoButton = document.getElementById('undoButton');
      undoButton.disabled = false;
    } else {
      undoButton.disabled = true;
    }

    if (redoActions.length > 0) {
      const redoButton = document.getElementById('redoButton');
      redoButton.disabled = false;
    } else {
      redoButton.disabled = true;
    }
  }

  function generateContent(d) {
    const color = '#FFFFFF';
    const imageDiffVert = 25 + 2;

    return `
      <div class="node-container" style='
      width:${d.width}px;
      height:${d.height}px;
      padding-top:${imageDiffVert - 2}px;
      padding-left:1px;
      padding-right:1px'
      onclick='selectNode(${d.data.id})'>
              <div class="content-container" style="font-family: 'Inter', sans-serif;  margin-left:-1px;width:${
                d.width - 2
              }px;height:${
      d.height - imageDiffVert
    }px;border-radius:10px;border: ${
      d.data._highlighted || d.data._upToTheRootHighlighted
        ? '5px solid #E27396"'
        : '1px solid #E4E2E9"'
    } >
                  <div style="display:flex;justify-content:flex-end;margin-top:5px;margin-right:8px">#${
                    d.data.id
                  }</div>
                  <div  style="margin-top:${
                    -imageDiffVert - 20
                  }px;margin-left:${15}px;border-radius:100px;width:50px;height:50px;" ></div>
                  <div style="margin-top:${
                    -imageDiffVert - 20
                  }px;">   <img src=" ${
      d.data.image
    }" style="margin-left:${20}px;border-radius:100px;width:40px;height:40px;" /></div>
                  <div style="font-size:15px;color:#08011E;margin-left:20px;margin-top:10px">  ${
                    d.data.name
                  } </div>
                  <div style="color:#716E7B;margin-left:20px;margin-top:3px;font-size:10px;"> ${
                    d.data.position
                  } </div>

              </div>
          </div>
      `;
  }

  let selectedNodeIds = [];
  
  function collectDescendants(nodeId, data, collectedIds) {
    data.forEach(node => {
      if (String(node.parentId) === String(nodeId)) {
          collectedIds.push(String(node.id));
          // Recursively collect descendants of this node
          collectDescendants(node.id, data, collectedIds);
      }
    });
  }
  // Function to find a node by its ID
  function findNodeById(id, data) {
    let result = null;
    for (const node of data) {
        if (String(node.id) === String(id)) {
            result = node;
            break;
        }
    }
    return result;
  }
  // Integrate these functions into your chart's update/render logic
  function expand(d) {
    d._expanded = true;
  }

  function collapse(d) {
    d._expanded = false;
  }

  function selectNode(nodeId) {
      const nodeIdStr = String(nodeId);
      const index = selectedNodeIds.indexOf(nodeIdStr);
      const data = chart.getChartState().data;
      let idsToRemove = [];
      // Select the DOM element associated with the nodeId
      const nodeElement = d3.selectAll('.content-container')
      .filter(function() {
          return this.querySelector('div').textContent.trim() === `#${nodeId}`;
      });

      // Get the border color of the selected node
      const borderColor = nodeElement.style('border-color');
      // //console.log(`Border color of node ${nodeId}:`, borderColor);
      if (index === -1) {
        // Node is not selected, so select it
        selectedNodeIds.push(nodeIdStr);
        // Collect all descendants recursively
        collectDescendants(nodeIdStr, data, selectedNodeIds);
        // Expand all selected nodes
        selectedNodeIds.forEach(id => {
          const node = findNodeById(id, data);
          if (node) {
            // //console.log(node);
            expand(node);
          }
        });
        chart.render();
        ////console.log("selectedNodeIds", selectedNodeIds);
        // Highlight the selected node
        selectedNodeIds.forEach(id => {
          d3.selectAll('.content-container')
              .filter(function() {
                  return this.querySelector('div').textContent.trim() === `#${id}`;
              })
              .style('border', '2px solid #E27396'); // Highlight selected nodes
        });
      } else {
        // Node is already selected, so deselect it
        selectedNodeIds.splice(index, 1);
        ////console.log("idsToRemove", idsToRemove);
        // Collect all descendants recursively for deselection
        collectDescendants(nodeIdStr, data, idsToRemove);
        idsToRemove.forEach(id => {
            const childIndex = selectedNodeIds.indexOf(id);
            if (childIndex !== -1) {
                selectedNodeIds.splice(childIndex, 1);
            }
        });
        // collapse all selected nodes
        idsToRemove.forEach(id => {
          const node = findNodeById(id, data);
          if (node) {
            // //console.log(node);
            collapse(node);
          }
        });
        chart.render();
        
        
        // Remove the highlight from the deselected node and its descendants
        selectedNodeIds.forEach(id => {
            d3.selectAll('.content-container')
                .filter(function() {
                    return this.querySelector('div').textContent.trim() === `#${id}`;
                })
                .style('border', '2px solid #E27396'); // add highlight from deselected nodes
        });
      }
  }

  function removeNode() {
    if (selectedNodeIds.length === 0) return;  // If no nodes are selected, do nothing

    const data = chart.getChartState().data;
    // Ensure all IDs are compared as strings
    const updatedData = data.filter(node => {
        if (node.parentId === null){
          return true;
        }
        const shouldRemove = selectedNodeIds.includes(String(node.id));
        return !shouldRemove;
    });
    if (updatedData.length !== data.length) {
      chart.data(updatedData).render();  // Re-render the chart
      selectedNodeIds = [];  // Reset the selected node IDs
    } else {
      //console.log("No nodes were removed.");
    }
    chart.render();
  }

</script>



<!--
  This is the code which is used to show of feature , other parts of the code are part of the boilerplate
-->
<div class="sidebar sidebar-fixed border-end" id="sidebar">
    <div class="sidebar-header border-bottom">
    <div class="sidebar-brand">
        <svg class="sidebar-brand-full" width="110" height="32" alt="CoreUI Logo">
        <use xlink:href="assets/brand/coreui.svg#full"></use>
        </svg>
        <svg class="sidebar-brand-narrow" width="32" height="32" alt="CoreUI Logo">
        <use xlink:href="assets/brand/coreui.svg#signet"></use>
        </svg>
    </div>
    <button class="btn-close d-lg-none"  type="button" aria-label="Close" ></button>
    </div>
    <div class="pt-3 pl-3 pr-3">
      <input type="text" id="searchInput" class="form-control"  placeholder="Search components...">
    </div>
    <ul class="sidebar-nav" data-coreui="navigation" data-simplebar="">
        <li class="nav-title" data-coreui-i18n="components">Components</li>
        <li class="nav-group"><a class="nav-link nav-group-toggle" draggable="false" href="#">
            <svg class="nav-icon">
                <use xlink:href="vendors/@coreui/icons/svg/free.svg#cil-puzzle"></use>
            </svg><span data-coreui-i18n="base">Base</span></a>
            <ul class="nav-group-items compact">
              <li class="nav-item"><a class="nav-link" href="base/accordion.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span><span data-coreui-i18n="accordion">Accordion</span></a></li>
              <li class="nav-item"><a class="nav-link" href="base/breadcrumb.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Breadcrumb</a></li>
              <li class="nav-item"><a class="nav-link" href="base/cards.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Cards</a></li>
              <li class="nav-item"><a class="nav-link" href="base/carousel.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Carousel</a></li>
              <li class="nav-item"><a class="nav-link" href="base/collapse.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Collapse</a></li>
              <li class="nav-item"><a class="nav-link" href="base/list-group.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> List group</a></li>
              <li class="nav-item"><a class="nav-link" href="base/navs-tabs.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Navs &amp; Tabs</a></li>
              <li class="nav-item"><a class="nav-link" href="base/pagination.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Pagination</a></li>
              <li class="nav-item"><a class="nav-link" href="base/placeholders.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Placeholders</a></li>
              <li class="nav-item"><a class="nav-link" href="base/popovers.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Popovers</a></li>
              <li class="nav-item"><a class="nav-link" href="base/progress.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Progress</a></li>
              <li class="nav-item"><a class="nav-link" href="base/spinners.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Spinners</a></li>
              <li class="nav-item"><a class="nav-link" href="base/tables.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Tables</a></li>
              <li class="nav-item"><a class="nav-link" href="base/tooltips.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Tooltips</a></li>
            </ul>
        </li>
        <li class="nav-group"><a class="nav-link nav-group-toggle" href="#">
            <svg class="nav-icon">
                <use xlink:href="vendors/@coreui/icons/svg/free.svg#cil-cursor"></use>
            </svg><span data-coreui-i18n="buttons">Buttons</span></a>
            <ul class="nav-group-items compact">
            <li class="nav-item"><a class="nav-link" href="buttons/buttons.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Buttons</a></li>
            <li class="nav-item"><a class="nav-link" href="buttons/button-group.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Buttons Group</a></li>
            <li class="nav-item"><a class="nav-link" href="buttons/loading-buttons.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Loading Buttons<span class="badge bg-danger-gradient ms-auto">PRO</span></a></li>
            <li class="nav-item"><a class="nav-link" href="buttons/dropdowns.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Dropdowns</a></li>
            </ul>
        </li>
        <li class="nav-group"><a class="nav-link nav-group-toggle" href="#">
            <svg class="nav-icon">
                <use xlink:href='vendors/@coreui/icons/svg/free.svg' %}#cil-notes"></use>
                </svg><span data-coreui-i18n="forms">Forms</span></a>
            <ul class="nav-group-items compact">
            <li class="nav-item"><a class="nav-link" href="forms/form-control.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Form Control</a></li>
            <li class="nav-item"><a class="nav-link" href="forms/select.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Select</a></li>
            <li class="nav-item"><a class="nav-link" href="forms/multi-select.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Multi Select<span class="badge bg-danger-gradient ms-auto">PRO</span></a></li>
            <li class="nav-item"><a class="nav-link" href="forms/checks-radios.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Checks &amp; radios</a></li>
            <li class="nav-item"><a class="nav-link" href="forms/range.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Range</a></li>
            <li class="nav-item"><a class="nav-link" href="forms/input-group.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Input group</a></li>
            <li class="nav-item"><a class="nav-link" href="forms/floating-labels.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Floating labels</a></li>
            <li class="nav-item"><a class="nav-link" href="forms/date-picker.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Date Picker<span class="badge bg-danger-gradient ms-auto">PRO</span></a></li>
            <li class="nav-item"><a class="nav-link" href="forms/date-range-picker.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Date Range Picker<span class="badge bg-danger-gradient ms-auto">PRO</span></a></li>
            <li class="nav-item"><a class="nav-link" href="forms/time-picker.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Time Picker<span class="badge bg-danger-gradient ms-auto">PRO</span></a></li>
            <li class="nav-item"><a class="nav-link" href="forms/layout.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span><span data-coreui-i18n="layout">Layout</span></a></li>
            <li class="nav-item"><a class="nav-link" href="forms/validation.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span><span data-coreui-i18n="validation">Validation</span></a></li>
            </ul>
        </li>
        <li class="nav-group"><a class="nav-link nav-group-toggle" href="#">
            <svg class="nav-icon">
                <use xlink:href="vendors/@coreui/icons/svg/free.svg#cil-star"></use>
            </svg><span data-coreui-i18n="icons">Icons</span></a>
            <ul class="nav-group-items compact">
            <li class="nav-item"><a class="nav-link" href="icons/coreui-icons-free.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> CoreUI Icons<span class="badge bg-success ms-auto" data-coreui-i18n="free">Free</span></a></li>
            <li class="nav-item"><a class="nav-link" href="icons/coreui-icons-brand.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> CoreUI Icons - Brand</a></li>
            <li class="nav-item"><a class="nav-link" href="icons/coreui-icons-flag.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> CoreUI Icons - Flag</a></li>
            </ul>
        </li>
        <li class="nav-group"><a class="nav-link nav-group-toggle" href="#">
            <svg class="nav-icon">
                <use xlink:href="vendors/@coreui/icons/svg/free.svg#cil-bell"></use>
            </svg><span data-coreui-i18n="notifications">Notifications</span></a>
            <ul class="nav-group-items compact">
            <li class="nav-item"><a class="nav-link" href="notifications/alerts.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Alerts</a></li>
            <li class="nav-item"><a class="nav-link" href="notifications/badge.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Badge</a></li>
            <li class="nav-item"><a class="nav-link" href="notifications/modals.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Modals</a></li>
            <li class="nav-item"><a class="nav-link" href="notifications/toasts.html"><span class="nav-icon"><span class="nav-icon-bullet"></span></span> Toasts</a></li>
            </ul>
        </li>
        <li class="nav-item"><a class="nav-link" href="widgets.html">
            <svg class="nav-icon">
                <use xlink:href="vendors/@coreui/icons/svg/free.svg#cil-calculator"></use>
            </svg><span data-coreui-i18n="widgets">Widgets</span><span class="badge bg-info-gradient text-uppercase ms-auto" data-coreui-i18n="new">New</span></a></li>
        <li class="nav-divider"></li>
        
    </ul>
    <div class="sidebar-footer border-top d-none d-lg-flex">
    <button class="sidebar-toggler" type="button" data-coreui-toggle="unfoldable"></button>
    </div>
</div>

<div class="wrapper d-flex flex-column min-vh-100" style="height:100%;">
    <header class="header header-sticky p-0">
        <div class="container-fluid px-4 border-bottom">
            
            <button class="header-toggler" id="sidebarToggleBtn" type="button" style="margin-inline-start: -14px">
              <svg class="icon icon-lg" id="sidebarToggleIcon">
                  <use xlink:href='vendors/@coreui/icons/svg/free.svg' %}#cil-menu"></use>
              </svg>
            </button>
            
            <ul class="header-nav ms-auto ms-md-0">
                <li class="nav-item">
                    <div class="chart-holder">
                      <button class="btn btn-link nav-link" id="enableDragButton" onclick="enableDrag()" title="Organize" aria-expanded="false">
                        <img src="https://cdn-icons-png.flaticon.com/512/10348/10348649.png" alt="Icon" style="width: 21px; height: 20px;">
                      </button>
                      <div id="dragActions" class="hide">
                      <button class="btn btn-link nav-link" id="finishDrag" onclick="disableDrag()"  title="Done">
                        <img src="https://cdn-icons-png.flaticon.com/512/17191/17191570.png" alt="Icon" style="width: 21px; height: 20px;">
                      </button>
                      <button class="btn btn-link nav-link" id="undoButton" disabled onclick="undo()" title="Undo">
                        <img src="https://cdn-icons-png.flaticon.com/512/3894/3894564.png" alt="Icon" style="width: 21px; height: 20px;">
                      </button>
                      <button class="btn btn-link nav-link" id="redoButton" disabled onclick="redo()" title="Redo">
                        <img src="https://cdn-icons-png.flaticon.com/512/3894/3894560.png" alt="Icon" style="width: 21px; height: 20px;">
                      </button>
                      <button class="btn btn-link nav-link" id="cancelDrag" onclick="cancelDrag()" title="Cancel">
                        <img src="https://cdn-icons-png.flaticon.com/512/17330/17330259.png" alt="Icon" style="width: 21px; height: 20px;">
                      </button>
                    </div>                  
                </li>
                <li class="nav-item">
                  <button class="btn btn-link nav-link" type="button" aria-expanded="false" title="Delete" onclick='removeNode()' ${selectedNodeIds.length === 0 ? 'disabled' : ''}>
                    <img src="https://cdn-icons-png.flaticon.com/512/1214/1214428.png" alt="Icon" style="width: 21px; height: 20px;">
                  </button>
                </li>
                <li class="nav-item py-1">
                  <div class="vr h-100 mx-2 text-body text-opacity-75"></div>
                </li>
                <li>
                  <button onclick='chart.layout(["right","bottom","left","top"][index++%4]).render().fit()'
                    class="btn btn-link nav-link" title="Swap">
                    <img src="https://cdn-icons-png.flaticon.com/512/4361/4361396.png" alt="Icon" style="width: 21px; height: 20px;">
                  </button>
                </li>
                <li>
                  <button onclick="chart.compact(!!(compact++%2)).render().fit()"
                    class="btn btn-link nav-link" title="Compact">
                    <img src="https://cdn-icons-png.flaticon.com/512/854/854125.png" alt="Icon" style="width: 21px; height: 20px;">
                  </button>
                </li>
                <li>
                  <button onclick="chart.fit()"
                    class="btn btn-link nav-link" title="Screen Fit">
                    <img src="https://cdn-icons-png.flaticon.com/512/16126/16126638.png" alt="Icon" style="width: 21px; height: 20px;">
                  </button>
                </li>
                
                <li class="nav-item py-1">
                  <div class="vr h-100 mx-2 text-body text-opacity-75"></div>
                </li>
                <li>
                  <button onclick="chart.exportImg({full:true})" class="btn btn-link nav-link" title="Download Image">
                    <img src="https://cdn-icons-png.flaticon.com/512/7245/7245427.png" alt="Icon" style="width: 21px; height: 20px;">
                  </button>
                </li>
                <li>
                  <button onclick="chart.exportSvg()" class="btn btn-link nav-link" title="Download SVG">
                     <img src="https://cdn-icons-png.flaticon.com/512/12223/12223791.png" alt="Icon" style="width: 21px; height: 20px;">
                  </button>
                </li>
                <li class="nav-item dropdown">
                  <button class="btn btn-link nav-link" type="button" aria-expanded="false" data-coreui-toggle="dropdown">
                  <svg class="icon icon-lg theme-icon-active">
                      <use xlink:href="vendors/@coreui/icons/svg/free.svg#cil-contrast"></use>
                  </svg>
                  </button>
                  <ul class="dropdown-menu dropdown-menu-end" style="--cui-dropdown-min-width: 8rem;">
                  <li>
                      <button class="dropdown-item d-flex align-items-center" type="button" data-coreui-theme-value="light">
                      <svg class="icon icon-lg me-3">
                          <use xlink:href="vendors/@coreui/icons/svg/free.svg#cil-sun"></use>
                      </svg><span data-coreui-i18n="light">Light</span>
                      </button>
                  </li>
                  <li>
                      <button class="dropdown-item d-flex align-items-center" type="button" data-coreui-theme-value="dark">
                      <svg class="icon icon-lg me-3">
                          <use xlink:href="vendors/@coreui/icons/svg/free.svg#cil-moon"></use>
                      </svg><span data-coreui-i18n="dark"> Dark</span>
                      </button>
                  </li>
                  <li>
                      <button class="dropdown-item d-flex align-items-center active" type="button" data-coreui-theme-value="auto">
                      <svg class="icon icon-lg me-3">
                          <use xlink:href="vendors/@coreui/icons/svg/free.svg#cil-contrast"></use>
                      </svg>Auto
                      </button>
                  </li>
                  </ul>
                </li>
                
                
                
                
            </ul>
            <ul class="header-nav ms-auto ms-md-0">
              <!--Profile-->
              <li class="nav-item dropdown" ><a class="nav-link py-0" draggable="false" data-coreui-toggle="dropdown" href="#" role="button" aria-haspopup="true">
                  <div class="avatar avatar-md"><img class="avatar-img" draggable="false" src="assets/img/avatars/8.jpg" alt="user@email.com"></div>
                </a>
                <div class="dropdown-menu dropdown-menu-end pt-0">
                  <div class="dropdown-header bg-body-tertiary text-body-secondary fw-semibold rounded-top mb-2"  data-coreui-i18n="account">Account</div><a class="dropdown-item" href="#" draggable="false">
                    <svg class="icon me-2">
                      <use xlink:href="vendors/@coreui/icons/svg/free.svg#cil-bell"></use>
                    </svg><span data-coreui-i18n="updates" draggable="false">Updates</span><span class="badge badge-sm bg-info-gradient ms-2">42</span></a><a class="dropdown-item" href="#" >
                    <svg class="icon me-2">
                      <use xlink:href="vendors/@coreui/icons/svg/free.svg#cil-envelope-open"></use>
                    </svg><span data-coreui-i18n="messages">Messages</span><span class="badge badge-sm badge-sm bg-success ms-2">42</span></a><a class="dropdown-item" href="#">
                    <svg class="icon me-2">
                      <use xlink:href="vendors/@coreui/icons/svg/free.svg#cil-task"></use>
                    </svg><span data-coreui-i18n="tasks">Tasks</span><span class="badge badge-sm bg-danger-gradient ms-2">42</span></a><a class="dropdown-item" href="#">
                    <svg class="icon me-2">
                      <use xlink:href="vendors/@coreui/icons/svg/free.svg#cil-comment-square"></use>
                    </svg><span data-coreui-i18n="comments">Comments</span><span class="badge badge-sm bg-warning-gradient ms-2">42</span></a>
                  <div class="dropdown-header bg-body-tertiary text-body-secondary fw-semibold my-2" data-coreui-i18n="settings">Settings</div><a class="dropdown-item" href="#" draggable="false">
                    <svg class="icon me-2">
                      <use xlink:href="vendors/@coreui/icons/svg/free.svg#cil-user"></use>
                    </svg><span data-coreui-i18n="profile">Profile</span></a><a class="dropdown-item" href="#">
                    <svg class="icon me-2">
                      <use xlink:href="vendors/@coreui/icons/svg/free.svg#cil-settings"></use>
                    </svg><span data-coreui-i18n="settings">Settings</span></a><a class="dropdown-item" href="#">
                    <svg class="icon me-2">
                      <use xlink:href="vendors/@coreui/icons/svg/free.svg#cil-credit-card"></use>
                    </svg><span data-coreui-i18n="payments">Payments</span><span class="badge badge-sm bg-secondary-gradient text-dark ms-2">42</span></a><a class="dropdown-item" href="#">
                    <svg class="icon me-2">
                      <use xlink:href="vendors/@coreui/icons/svg/free.svg#cil-file"></use>
                    </svg><span data-coreui-i18n="projects">Projects</span><span class="badge badge-sm bg-primary-gradient ms-2">42</span></a>
                  <div class="dropdown-divider"></div><a class="dropdown-item" href="#" draggable="false">
                    <svg class="icon me-2">
                      <use xlink:href="vendors/@coreui/icons/svg/free.svg#cil-lock-locked"></use>
                    </svg><span data-coreui-i18n="lockAccount">Lock Account</span></a><a class="dropdown-item" href="#">
                    <svg class="icon me-2">
                      <use xlink:href="vendors/@coreui/icons/svg/free.svg#cil-account-logout"></use>
                    </svg><span data-coreui-i18n="logout">Logout</span></a>
                </div>
              </li>
            </ul>
            
        </div>
    </header>

    
  
    <!--
    End of adding node functionality
    -->
    
    <div class="chart-container" style="height:100%; background-color:white;">
      <div class="zoom-buttons">
        <button onclick="chart.zoomIn()">+</button>
        <button onclick="chart.zoomOut()"></button>
      </div>
    </div>
    
    
</div>

<script>
  document.getElementById("sidebarToggleBtn").addEventListener("click", function() {
    var sidebar = document.getElementById("sidebar");

    // Toggle the 'd-none' class on the sidebar

    // You could also add logic to change the button's appearance, e.g., changing the icon
    if (sidebar.classList.contains("hide")) {
      sidebar.classList.remove("hide");
    } else {
      sidebar.classList.add("hide");
    }
  });
</script>

<script>
    var index = 0;
    var compact = 0;
    var actNdCent = 0;
</script>

<script>
    // Accordion functionality

    var $titleTab = $('.title_tab');
    $('.accordion-item:eq(0)').find('.title_tab').addClass('active').next().stop().slideDown(300).prev().find('.dropdown-icon').removeClass('fa-chevron-right').addClass('fa-chevron-down');

    $titleTab.on('click', function(e) {
        e.preventDefault();
        if ($(this).hasClass('active')) {
            $(this).removeClass('active');
            $(this).next().stop().slideUp(500);
            $(this).find('.dropdown-icon').removeClass('fa-chevron-down').addClass('fa-chevron-right');
        } else {
            $(this).addClass('active');
            $(this).next().stop().slideDown(500);
            $(this).find('.dropdown-icon').removeClass('fa-chevron-right').addClass('fa-chevron-down');
            $(this).parent().siblings().children('.title_tab').removeClass('active');
            $(this).parent().siblings().children('.inner_content').slideUp(500);
            $(this).parent().siblings().children('.title_tab').find('.dropdown-icon').removeClass('fa-chevron-down').addClass('fa-chevron-right');
        }
    });

</script>
<!-- CoreUI and necessary plugins-->
<script src="vendors/@coreui/coreui-pro/js/coreui.bundle.min.js"></script>
<script src="vendors/simplebar/js/simplebar.min.js"></script>
<script src="vendors/i18next/js/i18next.min.js"></script>
<script src="vendors/i18next-http-backend/js/i18nextHttpBackend.js"></script>

<script>
  const header = document.querySelector('header.header');

  document.addEventListener('scroll', () => {
    if (header) {
      header.classList.toggle('shadow-sm', document.documentElement.scrollTop > 0);
    }
  });
</script>
<!-- Search Function -->
<script>
  document.addEventListener('DOMContentLoaded', function () {
    const searchInput = document.getElementById('searchInput');
    const navGroups = document.querySelectorAll('.nav-group');

    searchInput.addEventListener('input', function () {
        const filter = searchInput.value.toLowerCase();

        navGroups.forEach(function (group) {
            const groupItems = group.querySelectorAll('.nav-group-items .nav-link');
            const navGroupItems = group.querySelector('.nav-group-items');
            let groupHasMatch = false;

            groupItems.forEach(function (link) {
                const linkText = link.innerText.toLowerCase();
                if (linkText.includes(filter)) {
                    link.style.display = '';
                    groupHasMatch = true;
                } else {
                    link.style.display = 'none';
                }
            });

            // Expand the dropdown if there's a match and ensure the group is visible
            if (groupHasMatch) {
                group.style.display = '';
                group.classList.add('show');
                group.setAttribute('aria-expanded', 'true');
                navGroupItems.style.height = 'auto';
            } else {
                group.style.display = 'none';
                group.classList.remove('show');
                group.setAttribute('aria-expanded', 'false');
                navGroupItems.style.height = '0px';
            }
        });
    });
    // Handle focus out of the search input
    searchInput.addEventListener('blur', function () {
      if (searchInput.value.trim() === '') {
          navGroups.forEach(function (group) {
              group.classList.remove('show');
          });
      }
    });
  });


</script>
